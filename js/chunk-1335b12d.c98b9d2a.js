(window["webpackJsonp"] = window["webpackJsonp"] || []).push([["chunk-1335b12d"],{

/***/ "0c47":
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__("da84");
var setToStringTag = __webpack_require__("d44e");

// JSON[@@toStringTag] property
// https://tc39.es/ecma262/#sec-json-@@tostringtag
setToStringTag(global.JSON, 'JSON', true);


/***/ }),

/***/ "1aca":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var _node_modules_mini_css_extract_plugin_dist_loader_js_ref_9_oneOf_1_0_node_modules_css_loader_dist_cjs_js_ref_9_oneOf_1_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_src_index_js_ref_9_oneOf_1_2_node_modules_sass_loader_dist_cjs_js_ref_9_oneOf_1_3_Presentation_scss_vue_type_style_index_1_id_4c57d58f_scoped_true_lang_scss___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("54bd");
/* harmony import */ var _node_modules_mini_css_extract_plugin_dist_loader_js_ref_9_oneOf_1_0_node_modules_css_loader_dist_cjs_js_ref_9_oneOf_1_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_src_index_js_ref_9_oneOf_1_2_node_modules_sass_loader_dist_cjs_js_ref_9_oneOf_1_3_Presentation_scss_vue_type_style_index_1_id_4c57d58f_scoped_true_lang_scss___WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_mini_css_extract_plugin_dist_loader_js_ref_9_oneOf_1_0_node_modules_css_loader_dist_cjs_js_ref_9_oneOf_1_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_src_index_js_ref_9_oneOf_1_2_node_modules_sass_loader_dist_cjs_js_ref_9_oneOf_1_3_Presentation_scss_vue_type_style_index_1_id_4c57d58f_scoped_true_lang_scss___WEBPACK_IMPORTED_MODULE_0__);
/* unused harmony reexport * */


/***/ }),

/***/ "1f49":
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),

/***/ "1f58":
/***/ (function(module, exports) {

module.exports = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACgAAAAzCAYAAADl70o1AAAACXBIWXMAAAsTAAALEwEAmpwYAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAyySURBVHgB7Vl5kB1FGf+6e2bevVd2c2xIQjgMUoQjQFKRQyMFUUBAoFLxwMT4R7xAhBTB0gqrkBILglWhimChiEVV1CQiJQuFFhBRQwA3iJiAYcMmG9jd7G72eu/te2+O7vbr7pl5jzO7myr/sOxNp3dmeqZ/3+87uxfgf61t3HrJpXCcbcvuT5248dHlsyYyl8IkW7rR+9xt9597DRxHc8fIg8P9BWcicycN8NTZF9xh1/nrP2pOR0eH/WHPfv7SqisGe0f/vmndC90wgUZgCu2eJ5fd1LXvHbnlts77f7nz5gZmH1mZ9w8uIZwvEYGcJVyRla4cdkv+Pnc8tT/BTtix/uuPP6vevXvbinZrhK1et/bXRyey1pQAqnbTlgW7Fi5p7QiC0bW+GEtInwD3AIQrQeJIXJxUFiDLEkpFAeWScyjTcvLzB7p6//qre/f+YqLrTAngtjfXrM6LffdzOZIVPoPAkxC4AjuCqwAECMzyCJxgp2HRgotgqCDg2b+0w5g7DqLUsr9MGj/z4N0vHprIWpMGuKPnhh8W/c4NnpcHKW1kLADfw17hwBXIigCvJIAjUIG/OyhACwItIej+kQKC90CKzNHm6Qs//4N17X871nqTArijD8EFb2zwg3EAbgEPcPAUKB9Bchyxlzl4CMZH1apr6RJUOTIboD/i/ADnSxSIQV0plz794js3PLnno9acsBc/1vOtlWV5aIOQ40ApwzsS/+FiEkeCHYS5BnMtgetnyCVwvA7wx1f3mABhM/w9n85X3tx++4+vaDxugDt72po9q+tuywrAslNAiWUAYAfivxsoEQYsCYESnEdVF3oU6j7KRyzUgCzMBz700+MGOEA6bpGsMO+s+k/D4sYNkLU/DoQwOLyPw0M3D8OeZ8qaUKINJrQaHAiTegWCoEkIuPsAwPafFaCQZ8DsBHj+yA0/uufyJVMG+OLQ5roKHfhya6oVZydhjv1JuKzlAcg6J8LLTxSh8+UK7Hp8FDRC7AqeAsMo0Z1SvKc6qhaw93W7cLS/Ar09PjBkEZiknhy+acoAuyrtS6jN5yTtLBJwAliQg3G/G8a9brjsC/Nh4XkLYOlVOVQ7qltwDQZxYUfWUK1Mq1MAZRwBcVi41IYzL0zCSR9T7CrQFHzhXrZ58+bElACm7NyXlOrGgwrMIOdBIIegc/wxZMqDixatguefexaWXtoCWqeKMWSRIiqqGLQoqpGCjaOFo2UxaJxO4OLL05DI4kwSoF2Css3mMfnUJR+0vnUsgEV+ZB6wcRhwO+EVbzukUU2Hy39Cp2AwLX067B1sR/8sITwFjmqQDFmUlh3eQ69VPoxgGJpIQDDN4LuCOvg0i/dSKFsAI8UDM6cEEN/OKjEFpogjwWMgML4JiapEVzw4+gcYLx3SzkHRaYR2BgvZQ5VayqGJsT30cBWYzFspYMTGGGrjmAML55fdXkilEq1TAki95CinNIxtQegLaPSYcAntQhZz0DvClSDas5mKkYiOKKZUCEJ2KNqZlNp90CbrIUCWhShroYXEuSpWSuhV691665XNxB5ambTgnbvu2v14nEl+3/WVxUf6D3y31OufHAyRh+c3zHtoxYrt/JsbP3GHK0bb0jkKTrYCifoAkhkbMllMYU2t4OBiQ8XDIP0UslIB7mN0RFy+5+Log8SVBSd4jffKaLnjNpSLScC0DIRPA79EwIbsUd/1l2PwUbj+6CS97KymDLgee00z+FTnqpML1tFdJdFn9ReL6KHu+f/a278YH62Zff7YpcMDeThysAJv7ynBYE8FyiNYdOKHA7RLle5MDCTa5ahQVk904Fada4Am/DD13EJ1Y7XopAnkGg/B3BObYfa8uuYZjeXFnTvHbs21jGYbExkYDFzIpp0zNUDe4K+bJRZbPfwAeptEt/ehwgqrb1h/QZvv9wSnXQyw6LMNOLERSnkfylidlPPo2WMCr7m+rhTQEVzFFAJSliBwxK4UqOzRVqASFtiOg2tY4LAMCjWKNpjGMOQiq84M1yueMiOLwBvSkMlISCRyxgZ9OTinq7Qf4xiWSY4NyRSmspE86Rt8e25zr4SZpymzQ1tCljK5NIaLEqqY6JDBsVoRutxKoDrRtlC9CiAP0Hu56ZJjigvQzjjaInbuUy0A91Wq5Jp5LDiElMq5iGYYMyoKRU0cFKyS9/kIhgMXDVoZMtX51asM00oBv4l2pdKrdg5j63rUYaTm2nhQOMZ5ObxHqJkkZTiDm/QHyvMDFIBQNUWnRhquQwPDoBBeAZUT5k0T4dVzTwRUqhLJV/YkNBIuiqCzfQwkXD/6n9RUN7ob+9RyqAIoAqAKDKJs0wjh8UC/FckR5W9qPmtLSqssUBJKrWwpAFcqNUH0Yk0Iim/UMAcRKzIER2uEMSWZAc5DbQg9KisAEuVy0BgIhAAxGWlV6fU0vVT/blsqk1pSeSMqQEtsFo1KKfNBpbb4WQ1QYuwgrnKIvk91zUhD9knItM2S2lpMIo9LoygX+8WYWmo+ihDRIeozRNdMNbQRwxwJVaeljjO6qQMjQDK8JyLbBfN9IyA3M7RgHCyaShAaMkeqpqI/7YlKUX3B2IoM7RC5o5YjuaaqGutIFWis2VAtkYqih9HvpEY4UqNuTQY11ww51CSpgiP+TqxiJ5RKhPqPjFXnKM+oC3RVbF4zQhiBaGgSJFSHjD08gmqElzHrhk1RBY/rugEv6EBPI/agyiCDhAAa2YsqMqlWI4ZhKmQwGvlCbKeRTem5jjYHzRkxvWqDYQdh+IxiFITLEVPMGiBYZDBjLppYagQxXkxsEVXCkR2qBI+cW4SyoKrDKkDFGqUZTF91CIq+KzZCzBK8h7Xo3VDX4XwD1MoxKwTGqs80QEukY+GicMMwYNtWImfZTEY+QGtsUL3sOLNRiAaoWS+2xQikjB6EQONwE5pT9CKjTtJ2TFrUGLS6QxVL4Q1qmmP1KYBqHwEJx7GNdmTEoJmnXqWsGT+Uiq2fhIGaRCEm1goJmWOhE4QhhxhfV9fMEq8nUkgKnnlZqqDAbtnCAMzIaQWKpwS21RgCIJiTMTpmoL8Os7ZZi0KtCxurYyFbNPZ8Ehq4UVs0X0DkoRCrNCRDf9aC+ac07541c9pL2boEZOux1sbyrrF+him3Us4ZT5DCOwMMeqc7CYlSSMhmEiMYe15I1VnnWpi9iUgibUWznioyiSqpeBwKJCE18IW5jmxPzSWm6gZiQnMsiHqXJ4Cm6oKzTl9+FU+8cXu6vnB22s68wPJz79UAL2xZX9i2d+kFjkw+KljdmcKBf1vp3Lfv2/iP7k1PzEB2U0hUSlc0eOCiUiNAuHHXISbMr6rUN54cqdRsP7kwqtKbdl1ly2pcDTUxvaFZrrh+0wBe3AJxe6Va8q84YzduqWHpTtlmLSNtQXQ/VUe5ZVEdBoicjlkByxvph3UC10DjABxFgDATyMhZaFTABrG6zbahGieZkxiBD2jv23bWglMNVZ1nzEy17XPQTs/GVBnaoxCx51azEJgwEak7fmb2yiYVijjeam9lJGjizsQAvrc15U5rt2nGJ2onR9FWaBZMplbBOAhLoij4Rt5JYrXHAZtV8zYJM4vOHBgtEk56z7JlbZUpAbxywZYuGmTXBWUXgtJhXQlTkgwDOo/DBIlAxWEGLStMBXGY0WVYWOehcWH1D8lkup9zb+WHrU9ggm3H3muuq8DBTSSVnEcwvQk5al4XeErl57G097Dc56bUx471p97RcVVBB2p/ok9GTDmIaG1q445w2vO4R/zqjctfPnjcAKO2rePqL/pW77V4BHSdPnchRo3qJ9qD6K5q03DLaYpm461MZIYdK/tIjpy67fqLfvPSsdabNEDV2l+7/dz9o1s7uJsD3+1X8QPUWfW0upm7GhpTHRx3TYwkkm91da21khnAg3bwfXXqirFAtj5855p/fm2ia03g6OP9zcY9ZCqTgoAlESCB8SKHAp4ujPbK3226cbc+kFy9+pqGukXda3NNaeR2RNd4KlAz4ZUns9ak/5ATNXUQxPC0ShUVDMOFOQusxpdV37kaErg5T6QwhWIRoGKprm85E5NZZ0oAK2Skj0CTPm+hcZzT2SL+C1OBex6GD9zjMkz6YSRHw8SThvHJrDU1Bo/OKQg/JwM82VeeCcKcJqC3Ho6mXHXe2pLN5ryoNvK6ZlEOg96dTrS8CpNoUwJ49YXrC3yYPlccGsUjC4kHQai1Sq5v7vRlu2rntTjzbhs8NPDmaB8y2k8lKc3a+r01f/4tTKJNyYtVe/rp+5qeeXXr90cKPecwmX6rtXnRT9pu2X7gg+Ze+425J9WRbOmRB14/Av9v/+X2H38AvAcHuvIzAAAAAElFTkSuQmCC"

/***/ }),

/***/ "23dc":
/***/ (function(module, exports, __webpack_require__) {

var setToStringTag = __webpack_require__("d44e");

// Math[@@toStringTag] property
// https://tc39.es/ecma262/#sec-math-@@tostringtag
setToStringTag(Math, 'Math', true);


/***/ }),

/***/ "3599":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
// ESM COMPAT FLAG
__webpack_require__.r(__webpack_exports__);

// CONCATENATED MODULE: ./node_modules/cache-loader/dist/cjs.js?{"cacheDirectory":"node_modules/.cache/vue-loader","cacheIdentifier":"25ff3af1-vue-loader-template"}!./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/cache-loader/dist/cjs.js??ref--1-0!./node_modules/vue-loader/lib??vue-loader-options!./src/components/Presentation.vue?vue&type=template&id=4c57d58f&scoped=true&
var render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',[_c('div',{staticClass:"slide-info-strip"},[_c('button',{staticClass:"slider-btn slider-btn-left",on:{"click":function($event){return _vm.prevSlide()}}},[_c('v-icon',{staticClass:"icon"},[_vm._v("mdi-chevron-left")])],1),_c('span',{staticClass:"slide-number"},[_vm._v(_vm._s(_vm.curSlide + 1)+"  of  "+_vm._s(_vm.totalSlides))]),_c('button',{staticClass:"slider-btn slider-btn-right",on:{"click":function($event){return _vm.nextSlide()}}},[_c('v-icon',{staticClass:"icon"},[_vm._v("mdi-chevron-right")])],1)]),_c('carousel',{attrs:{"id":"carousel","perPage":1,"navigationEnabled":false,"paginationEnabled":false,"navigateTo":[
      _vm.curSlideOverride === null ? _vm.curSlide : _vm.curSlideOverride,
      _vm.curSlideOverride === null ],"touchDrag":false},on:{"pageChange":_vm.updateCurSlide}},[_c('slide',{class:{
        slide: true,
        'slide-default-height': !_vm.isPresentationsInFullScreen,
        'slide-expanded-height': _vm.isPresentationsInFullScreen,
      }},[_c('Particles',{attrs:{"id":"tsparticles","particlesInit":_vm.particlesInit,"options":_vm.tsParticlesConfig}}),_c('div',{staticClass:"container",attrs:{"id":"container1"}},[_c('h1',{staticClass:"presentation-title",staticStyle:{"padding-top":"15px"}},[_vm._v(" Android Hacks Unleashed ")]),_c('h2',{staticClass:"presentation-sub-title",staticStyle:{"padding-bottom":"15px"}},[_vm._v(" Your App Is More Vulnerable Than You Think! ")])])],1),_c('slide',{class:{
        slide: true,
        'slide-default-height': !_vm.isPresentationsInFullScreen,
        'slide-expanded-height': _vm.isPresentationsInFullScreen,
      }},[_c('div',{staticClass:"container",attrs:{"id":"container2"}},[_c('div',{staticClass:"image-wrapper"},[_c('img',{staticClass:"intro-img",attrs:{"src":__webpack_require__("3a19"),"alt":""}})]),_c('div',{staticClass:"spacer"}),_c('div',{staticClass:"intro-desc"},[_c('h1',[_vm._v(" I'm Kirtikumar A.R.")]),_c('ul',[_c('li',[_vm._v("Browser and Kernel Security Researcher")]),_c('li',[_vm._v("World Cyber Games 2019 (Asia 7th, World's Top 32)")]),_c('li',[_vm._v("Paytm First Games National Champion")]),_c('li',[_vm._v("National Representative in BRICS 2020 for India")]),_c('li',[_vm._v("Google Play Security Research's Top Researcher for 2022")]),_c('li',[_vm._v("Youngest Tech-Savvy Awardee")]),_c('li',[_vm._v("Penetration Tester of the Year 2018 in London")]),_c('li',[_vm._v("Represented India in the High Technology Championship - AI, ML and Neural Networks")])])])])]),_c('slide',{class:{
        slide: true,
        'slide-default-height': !_vm.isPresentationsInFullScreen,
        'slide-expanded-height': _vm.isPresentationsInFullScreen,
      }},[_c('div',{staticClass:"container"},[_vm._v("Slide 3")])]),_c('slide',{class:{
        slide: true,
        'slide-default-height': !_vm.isPresentationsInFullScreen,
        'slide-expanded-height': _vm.isPresentationsInFullScreen,
      }},[_c('div',{staticClass:"container"},[_vm._v("Slide 4")])])],1)],1)}
var staticRenderFns = []


// CONCATENATED MODULE: ./src/components/Presentation.vue?vue&type=template&id=4c57d58f&scoped=true&

// EXTERNAL MODULE: ./node_modules/core-js/modules/es.symbol.js
var es_symbol = __webpack_require__("a4d3");

// EXTERNAL MODULE: ./node_modules/core-js/modules/es.symbol.description.js
var es_symbol_description = __webpack_require__("e01a");

// EXTERNAL MODULE: ./node_modules/core-js/modules/es.object.to-string.js
var es_object_to_string = __webpack_require__("d3b7");

// EXTERNAL MODULE: ./node_modules/core-js/modules/es.symbol.iterator.js
var es_symbol_iterator = __webpack_require__("d28b");

// EXTERNAL MODULE: ./node_modules/core-js/modules/es.string.iterator.js
var es_string_iterator = __webpack_require__("3ca3");

// EXTERNAL MODULE: ./node_modules/core-js/modules/web.dom-collections.iterator.js
var web_dom_collections_iterator = __webpack_require__("ddb0");

// EXTERNAL MODULE: ./node_modules/core-js/modules/es.symbol.async-iterator.js
var es_symbol_async_iterator = __webpack_require__("b636");

// EXTERNAL MODULE: ./node_modules/core-js/modules/es.symbol.to-string-tag.js
var es_symbol_to_string_tag = __webpack_require__("944a");

// EXTERNAL MODULE: ./node_modules/core-js/modules/es.json.to-string-tag.js
var es_json_to_string_tag = __webpack_require__("0c47");

// EXTERNAL MODULE: ./node_modules/core-js/modules/es.math.to-string-tag.js
var es_math_to_string_tag = __webpack_require__("23dc");

// EXTERNAL MODULE: ./node_modules/core-js/modules/es.error.cause.js
var es_error_cause = __webpack_require__("d9e2");

// EXTERNAL MODULE: ./node_modules/core-js/modules/es.object.get-prototype-of.js
var es_object_get_prototype_of = __webpack_require__("3410");

// EXTERNAL MODULE: ./node_modules/core-js/modules/web.dom-collections.for-each.js
var web_dom_collections_for_each = __webpack_require__("159b");

// EXTERNAL MODULE: ./node_modules/core-js/modules/es.function.name.js
var es_function_name = __webpack_require__("b0c0");

// EXTERNAL MODULE: ./node_modules/core-js/modules/es.array.slice.js
var es_array_slice = __webpack_require__("fb6a");

// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/esm/typeof.js
var esm_typeof = __webpack_require__("53ca");

// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js
















function _regeneratorRuntime() {
  "use strict";
  /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */

  _regeneratorRuntime = function _regeneratorRuntime() {
    return exports;
  };

  var exports = {},
      Op = Object.prototype,
      hasOwn = Op.hasOwnProperty,
      $Symbol = "function" == typeof Symbol ? Symbol : {},
      iteratorSymbol = $Symbol.iterator || "@@iterator",
      asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator",
      toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";

  function define(obj, key, value) {
    return Object.defineProperty(obj, key, {
      value: value,
      enumerable: !0,
      configurable: !0,
      writable: !0
    }), obj[key];
  }

  try {
    define({}, "");
  } catch (err) {
    define = function define(obj, key, value) {
      return obj[key] = value;
    };
  }

  function wrap(innerFn, outerFn, self, tryLocsList) {
    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator,
        generator = Object.create(protoGenerator.prototype),
        context = new Context(tryLocsList || []);
    return generator._invoke = function (innerFn, self, context) {
      var state = "suspendedStart";
      return function (method, arg) {
        if ("executing" === state) throw new Error("Generator is already running");

        if ("completed" === state) {
          if ("throw" === method) throw arg;
          return doneResult();
        }

        for (context.method = method, context.arg = arg;;) {
          var delegate = context.delegate;

          if (delegate) {
            var delegateResult = maybeInvokeDelegate(delegate, context);

            if (delegateResult) {
              if (delegateResult === ContinueSentinel) continue;
              return delegateResult;
            }
          }

          if ("next" === context.method) context.sent = context._sent = context.arg;else if ("throw" === context.method) {
            if ("suspendedStart" === state) throw state = "completed", context.arg;
            context.dispatchException(context.arg);
          } else "return" === context.method && context.abrupt("return", context.arg);
          state = "executing";
          var record = tryCatch(innerFn, self, context);

          if ("normal" === record.type) {
            if (state = context.done ? "completed" : "suspendedYield", record.arg === ContinueSentinel) continue;
            return {
              value: record.arg,
              done: context.done
            };
          }

          "throw" === record.type && (state = "completed", context.method = "throw", context.arg = record.arg);
        }
      };
    }(innerFn, self, context), generator;
  }

  function tryCatch(fn, obj, arg) {
    try {
      return {
        type: "normal",
        arg: fn.call(obj, arg)
      };
    } catch (err) {
      return {
        type: "throw",
        arg: err
      };
    }
  }

  exports.wrap = wrap;
  var ContinueSentinel = {};

  function Generator() {}

  function GeneratorFunction() {}

  function GeneratorFunctionPrototype() {}

  var IteratorPrototype = {};
  define(IteratorPrototype, iteratorSymbol, function () {
    return this;
  });
  var getProto = Object.getPrototypeOf,
      NativeIteratorPrototype = getProto && getProto(getProto(values([])));
  NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype);
  var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype);

  function defineIteratorMethods(prototype) {
    ["next", "throw", "return"].forEach(function (method) {
      define(prototype, method, function (arg) {
        return this._invoke(method, arg);
      });
    });
  }

  function AsyncIterator(generator, PromiseImpl) {
    function invoke(method, arg, resolve, reject) {
      var record = tryCatch(generator[method], generator, arg);

      if ("throw" !== record.type) {
        var result = record.arg,
            value = result.value;
        return value && "object" == Object(esm_typeof["a" /* default */])(value) && hasOwn.call(value, "__await") ? PromiseImpl.resolve(value.__await).then(function (value) {
          invoke("next", value, resolve, reject);
        }, function (err) {
          invoke("throw", err, resolve, reject);
        }) : PromiseImpl.resolve(value).then(function (unwrapped) {
          result.value = unwrapped, resolve(result);
        }, function (error) {
          return invoke("throw", error, resolve, reject);
        });
      }

      reject(record.arg);
    }

    var previousPromise;

    this._invoke = function (method, arg) {
      function callInvokeWithMethodAndArg() {
        return new PromiseImpl(function (resolve, reject) {
          invoke(method, arg, resolve, reject);
        });
      }

      return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();
    };
  }

  function maybeInvokeDelegate(delegate, context) {
    var method = delegate.iterator[context.method];

    if (undefined === method) {
      if (context.delegate = null, "throw" === context.method) {
        if (delegate.iterator["return"] && (context.method = "return", context.arg = undefined, maybeInvokeDelegate(delegate, context), "throw" === context.method)) return ContinueSentinel;
        context.method = "throw", context.arg = new TypeError("The iterator does not provide a 'throw' method");
      }

      return ContinueSentinel;
    }

    var record = tryCatch(method, delegate.iterator, context.arg);
    if ("throw" === record.type) return context.method = "throw", context.arg = record.arg, context.delegate = null, ContinueSentinel;
    var info = record.arg;
    return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, "return" !== context.method && (context.method = "next", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = "throw", context.arg = new TypeError("iterator result is not an object"), context.delegate = null, ContinueSentinel);
  }

  function pushTryEntry(locs) {
    var entry = {
      tryLoc: locs[0]
    };
    1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry);
  }

  function resetTryEntry(entry) {
    var record = entry.completion || {};
    record.type = "normal", delete record.arg, entry.completion = record;
  }

  function Context(tryLocsList) {
    this.tryEntries = [{
      tryLoc: "root"
    }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0);
  }

  function values(iterable) {
    if (iterable) {
      var iteratorMethod = iterable[iteratorSymbol];
      if (iteratorMethod) return iteratorMethod.call(iterable);
      if ("function" == typeof iterable.next) return iterable;

      if (!isNaN(iterable.length)) {
        var i = -1,
            next = function next() {
          for (; ++i < iterable.length;) {
            if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next;
          }

          return next.value = undefined, next.done = !0, next;
        };

        return next.next = next;
      }
    }

    return {
      next: doneResult
    };
  }

  function doneResult() {
    return {
      value: undefined,
      done: !0
    };
  }

  return GeneratorFunction.prototype = GeneratorFunctionPrototype, define(Gp, "constructor", GeneratorFunctionPrototype), define(GeneratorFunctionPrototype, "constructor", GeneratorFunction), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction"), exports.isGeneratorFunction = function (genFun) {
    var ctor = "function" == typeof genFun && genFun.constructor;
    return !!ctor && (ctor === GeneratorFunction || "GeneratorFunction" === (ctor.displayName || ctor.name));
  }, exports.mark = function (genFun) {
    return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, "GeneratorFunction")), genFun.prototype = Object.create(Gp), genFun;
  }, exports.awrap = function (arg) {
    return {
      __await: arg
    };
  }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () {
    return this;
  }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) {
    void 0 === PromiseImpl && (PromiseImpl = Promise);
    var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl);
    return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) {
      return result.done ? result.value : iter.next();
    });
  }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, "Generator"), define(Gp, iteratorSymbol, function () {
    return this;
  }), define(Gp, "toString", function () {
    return "[object Generator]";
  }), exports.keys = function (object) {
    var keys = [];

    for (var key in object) {
      keys.push(key);
    }

    return keys.reverse(), function next() {
      for (; keys.length;) {
        var key = keys.pop();
        if (key in object) return next.value = key, next.done = !1, next;
      }

      return next.done = !0, next;
    };
  }, exports.values = values, Context.prototype = {
    constructor: Context,
    reset: function reset(skipTempReset) {
      if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = "next", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) {
        "t" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined);
      }
    },
    stop: function stop() {
      this.done = !0;
      var rootRecord = this.tryEntries[0].completion;
      if ("throw" === rootRecord.type) throw rootRecord.arg;
      return this.rval;
    },
    dispatchException: function dispatchException(exception) {
      if (this.done) throw exception;
      var context = this;

      function handle(loc, caught) {
        return record.type = "throw", record.arg = exception, context.next = loc, caught && (context.method = "next", context.arg = undefined), !!caught;
      }

      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i],
            record = entry.completion;
        if ("root" === entry.tryLoc) return handle("end");

        if (entry.tryLoc <= this.prev) {
          var hasCatch = hasOwn.call(entry, "catchLoc"),
              hasFinally = hasOwn.call(entry, "finallyLoc");

          if (hasCatch && hasFinally) {
            if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0);
            if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc);
          } else if (hasCatch) {
            if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0);
          } else {
            if (!hasFinally) throw new Error("try statement without catch or finally");
            if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc);
          }
        }
      }
    },
    abrupt: function abrupt(type, arg) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];

        if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) {
          var finallyEntry = entry;
          break;
        }
      }

      finallyEntry && ("break" === type || "continue" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null);
      var record = finallyEntry ? finallyEntry.completion : {};
      return record.type = type, record.arg = arg, finallyEntry ? (this.method = "next", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record);
    },
    complete: function complete(record, afterLoc) {
      if ("throw" === record.type) throw record.arg;
      return "break" === record.type || "continue" === record.type ? this.next = record.arg : "return" === record.type ? (this.rval = this.arg = record.arg, this.method = "return", this.next = "end") : "normal" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel;
    },
    finish: function finish(finallyLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel;
      }
    },
    "catch": function _catch(tryLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];

        if (entry.tryLoc === tryLoc) {
          var record = entry.completion;

          if ("throw" === record.type) {
            var thrown = record.arg;
            resetTryEntry(entry);
          }

          return thrown;
        }
      }

      throw new Error("illegal catch attempt");
    },
    delegateYield: function delegateYield(iterable, resultName, nextLoc) {
      return this.delegate = {
        iterator: values(iterable),
        resultName: resultName,
        nextLoc: nextLoc
      }, "next" === this.method && (this.arg = undefined), ContinueSentinel;
    }
  }, exports;
}
// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js


function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
  try {
    var info = gen[key](arg);
    var value = info.value;
  } catch (error) {
    reject(error);
    return;
  }

  if (info.done) {
    resolve(value);
  } else {
    Promise.resolve(value).then(_next, _throw);
  }
}

function _asyncToGenerator(fn) {
  return function () {
    var self = this,
        args = arguments;
    return new Promise(function (resolve, reject) {
      var gen = fn.apply(self, args);

      function _next(value) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
      }

      function _throw(err) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
      }

      _next(undefined);
    });
  };
}
// EXTERNAL MODULE: ./node_modules/tsparticles-engine/esm/index.js + 195 modules
var esm = __webpack_require__("9efc");

// CONCATENATED MODULE: ./node_modules/tsparticles-plugin-absorbers/esm/Options/Classes/AbsorberSizeLimit.js
class AbsorberSizeLimit {
    constructor() {
        this.radius = 0;
        this.mass = 0;
    }
    load(data) {
        if (!data) {
            return;
        }
        if (data.mass !== undefined) {
            this.mass = data.mass;
        }
        if (data.radius !== undefined) {
            this.radius = data.radius;
        }
    }
}

// CONCATENATED MODULE: ./node_modules/tsparticles-plugin-absorbers/esm/Options/Classes/AbsorberSize.js


class AbsorberSize_AbsorberSize extends esm["g" /* ValueWithRandom */] {
    constructor() {
        super();
        this.density = 5;
        this.value = 50;
        this.limit = new AbsorberSizeLimit();
    }
    load(data) {
        if (!data) {
            return;
        }
        super.load(data);
        if (data.density !== undefined) {
            this.density = data.density;
        }
        if (typeof data.limit === "number") {
            this.limit.radius = data.limit;
        }
        else {
            this.limit.load(data.limit);
        }
    }
}

// CONCATENATED MODULE: ./node_modules/tsparticles-plugin-absorbers/esm/Options/Classes/Absorber.js


class Absorber_Absorber {
    constructor() {
        this.color = new esm["d" /* OptionsColor */]();
        this.color.value = "#000000";
        this.draggable = false;
        this.opacity = 1;
        this.destroy = true;
        this.orbits = false;
        this.size = new AbsorberSize_AbsorberSize();
    }
    load(data) {
        if (data === undefined) {
            return;
        }
        if (data.color !== undefined) {
            this.color = esm["d" /* OptionsColor */].create(this.color, data.color);
        }
        if (data.draggable !== undefined) {
            this.draggable = data.draggable;
        }
        this.name = data.name;
        if (data.opacity !== undefined) {
            this.opacity = data.opacity;
        }
        if (data.position !== undefined) {
            this.position = {};
            if (data.position.x !== undefined) {
                this.position.x = Object(esm["Y" /* setRangeValue */])(data.position.x);
            }
            if (data.position.y !== undefined) {
                this.position.y = Object(esm["Y" /* setRangeValue */])(data.position.y);
            }
        }
        if (data.size !== undefined) {
            this.size.load(data.size);
        }
        if (data.destroy !== undefined) {
            this.destroy = data.destroy;
        }
        if (data.orbits !== undefined) {
            this.orbits = data.orbits;
        }
    }
}

// CONCATENATED MODULE: ./node_modules/tsparticles-plugin-absorbers/esm/AbsorberInstance.js


class AbsorberInstance_AbsorberInstance {
    constructor(absorbers, container, options, position) {
        var _a, _b, _c;
        this.absorbers = absorbers;
        this.container = container;
        this.initialPosition = position ? esm["h" /* Vector */].create(position.x, position.y) : undefined;
        if (options instanceof Absorber_Absorber) {
            this.options = options;
        }
        else {
            this.options = new Absorber_Absorber();
            this.options.load(options);
        }
        this.dragging = false;
        this.name = this.options.name;
        this.opacity = this.options.opacity;
        this.size = Object(esm["F" /* getRangeValue */])(this.options.size.value) * container.retina.pixelRatio;
        this.mass = this.size * this.options.size.density * container.retina.reduceFactor;
        const limit = this.options.size.limit;
        this.limit = {
            radius: limit.radius * container.retina.pixelRatio * container.retina.reduceFactor,
            mass: limit.mass,
        };
        this.color = (_a = Object(esm["V" /* rangeColorToRgb */])(this.options.color)) !== null && _a !== void 0 ? _a : {
            b: 0,
            g: 0,
            r: 0,
        };
        this.position = (_c = (_b = this.initialPosition) === null || _b === void 0 ? void 0 : _b.copy()) !== null && _c !== void 0 ? _c : this.calcPosition();
    }
    attract(particle) {
        const container = this.container, options = this.options;
        if (options.draggable) {
            const mouse = container.interactivity.mouse;
            if (mouse.clicking && mouse.downPosition) {
                const mouseDist = Object(esm["w" /* getDistance */])(this.position, mouse.downPosition);
                if (mouseDist <= this.size) {
                    this.dragging = true;
                }
            }
            else {
                this.dragging = false;
            }
            if (this.dragging && mouse.position) {
                this.position.x = mouse.position.x;
                this.position.y = mouse.position.y;
            }
        }
        const pos = particle.getPosition(), { dx, dy, distance } = Object(esm["x" /* getDistances */])(this.position, pos), v = esm["h" /* Vector */].create(dx, dy);
        v.length = (this.mass / Math.pow(distance, 2)) * container.retina.reduceFactor;
        if (distance < this.size + particle.getRadius()) {
            const sizeFactor = particle.getRadius() * 0.033 * container.retina.pixelRatio;
            if ((this.size > particle.getRadius() && distance < this.size - particle.getRadius()) ||
                (particle.absorberOrbit !== undefined && particle.absorberOrbit.length < 0)) {
                if (options.destroy) {
                    particle.destroy();
                }
                else {
                    particle.needsNewPosition = true;
                    this.updateParticlePosition(particle, v);
                }
            }
            else {
                if (options.destroy) {
                    particle.size.value -= sizeFactor;
                }
                this.updateParticlePosition(particle, v);
            }
            if (this.limit.radius <= 0 || this.size < this.limit.radius) {
                this.size += sizeFactor;
            }
            if (this.limit.mass <= 0 || this.mass < this.limit.mass) {
                this.mass += sizeFactor * this.options.size.density * container.retina.reduceFactor;
            }
        }
        else {
            this.updateParticlePosition(particle, v);
        }
    }
    draw(context) {
        context.translate(this.position.x, this.position.y);
        context.beginPath();
        context.arc(0, 0, this.size, 0, Math.PI * 2, false);
        context.closePath();
        context.fillStyle = Object(esm["H" /* getStyleFromRgb */])(this.color, this.opacity);
        context.fill();
    }
    resize() {
        const initialPosition = this.initialPosition;
        this.position =
            initialPosition && Object(esm["L" /* isPointInside */])(initialPosition, this.container.canvas.size, esm["h" /* Vector */].origin)
                ? initialPosition
                : this.calcPosition();
    }
    calcPosition() {
        const exactPosition = Object(esm["k" /* calcPositionOrRandomFromSizeRanged */])({
            size: this.container.canvas.size,
            position: this.options.position,
        });
        return esm["h" /* Vector */].create(exactPosition.x, exactPosition.y);
    }
    updateParticlePosition(particle, v) {
        var _a;
        if (particle.destroyed) {
            return;
        }
        const container = this.container, canvasSize = container.canvas.size;
        if (particle.needsNewPosition) {
            const newPosition = Object(esm["j" /* calcPositionOrRandomFromSize */])({ size: canvasSize });
            particle.position.setTo(newPosition);
            particle.velocity.setTo(particle.initialVelocity);
            particle.absorberOrbit = undefined;
            particle.needsNewPosition = false;
        }
        if (this.options.orbits) {
            if (particle.absorberOrbit === undefined) {
                particle.absorberOrbit = esm["h" /* Vector */].create(0, 0);
                particle.absorberOrbit.length = Object(esm["w" /* getDistance */])(particle.getPosition(), this.position);
                particle.absorberOrbit.angle = Object(esm["C" /* getRandom */])() * Math.PI * 2;
            }
            if (particle.absorberOrbit.length <= this.size && !this.options.destroy) {
                const minSize = Math.min(canvasSize.width, canvasSize.height);
                particle.absorberOrbit.length = minSize * (1 + (Object(esm["C" /* getRandom */])() * 0.2 - 0.1));
            }
            if (particle.absorberOrbitDirection === undefined) {
                particle.absorberOrbitDirection =
                    particle.velocity.x >= 0 ? "clockwise" : "counter-clockwise";
            }
            const orbitRadius = particle.absorberOrbit.length, orbitAngle = particle.absorberOrbit.angle, orbitDirection = particle.absorberOrbitDirection;
            particle.velocity.setTo(esm["h" /* Vector */].origin);
            const updateFunc = {
                x: orbitDirection === "clockwise" ? Math.cos : Math.sin,
                y: orbitDirection === "clockwise" ? Math.sin : Math.cos,
            };
            particle.position.x = this.position.x + orbitRadius * updateFunc.x(orbitAngle);
            particle.position.y = this.position.y + orbitRadius * updateFunc.y(orbitAngle);
            particle.absorberOrbit.length -= v.length;
            particle.absorberOrbit.angle +=
                ((((_a = particle.retina.moveSpeed) !== null && _a !== void 0 ? _a : 0) * container.retina.pixelRatio) / 100) *
                    container.retina.reduceFactor;
        }
        else {
            const addV = esm["h" /* Vector */].origin;
            addV.length = v.length;
            addV.angle = v.angle;
            particle.velocity.addTo(addV);
        }
    }
}

// CONCATENATED MODULE: ./node_modules/tsparticles-plugin-absorbers/esm/Absorbers.js


class Absorbers_Absorbers {
    constructor(container) {
        this.container = container;
        this.array = [];
        this.absorbers = [];
        this.interactivityAbsorbers = [];
        container.getAbsorber = (idxOrName) => idxOrName === undefined || typeof idxOrName === "number"
            ? this.array[idxOrName || 0]
            : this.array.find((t) => t.name === idxOrName);
        container.addAbsorber = (options, position) => this.addAbsorber(options, position);
    }
    addAbsorber(options, position) {
        const absorber = new AbsorberInstance_AbsorberInstance(this, this.container, options, position);
        this.array.push(absorber);
        return absorber;
    }
    draw(context) {
        for (const absorber of this.array) {
            absorber.draw(context);
        }
    }
    handleClickMode(mode) {
        const absorberOptions = this.absorbers, modeAbsorbers = this.interactivityAbsorbers;
        if (mode === "absorber") {
            const absorbersModeOptions = Object(esm["O" /* itemFromSingleOrMultiple */])(modeAbsorbers), absorbersOptions = absorbersModeOptions !== null && absorbersModeOptions !== void 0 ? absorbersModeOptions : Object(esm["O" /* itemFromSingleOrMultiple */])(absorberOptions), aPosition = this.container.interactivity.mouse.clickPosition;
            this.addAbsorber(absorbersOptions, aPosition);
        }
    }
    async init() {
        this.absorbers = this.container.actualOptions.absorbers;
        this.interactivityAbsorbers = this.container.actualOptions.interactivity.modes.absorbers;
        Object(esm["v" /* executeOnSingleOrMultiple */])(this.absorbers, (absorber) => {
            this.addAbsorber(absorber);
        });
    }
    particleUpdate(particle) {
        for (const absorber of this.array) {
            absorber.attract(particle);
            if (particle.destroyed) {
                break;
            }
        }
    }
    removeAbsorber(absorber) {
        const index = this.array.indexOf(absorber);
        if (index >= 0) {
            this.array.splice(index, 1);
        }
    }
    resize() {
        for (const absorber of this.array) {
            absorber.resize();
        }
    }
    stop() {
        this.array = [];
    }
}

// CONCATENATED MODULE: ./node_modules/tsparticles-plugin-absorbers/esm/AbsorberContainer.js


// CONCATENATED MODULE: ./node_modules/tsparticles-plugin-absorbers/esm/Enums/AbsorberClickMode.js


// CONCATENATED MODULE: ./node_modules/tsparticles-plugin-absorbers/esm/index.js



class esm_AbsorbersPlugin {
    constructor() {
        this.id = "absorbers";
    }
    getPlugin(container) {
        return new Absorbers_Absorbers(container);
    }
    loadOptions(options, source) {
        var _a, _b;
        if (!this.needsPlugin(options) && !this.needsPlugin(source)) {
            return;
        }
        if (source === null || source === void 0 ? void 0 : source.absorbers) {
            options.absorbers = Object(esm["v" /* executeOnSingleOrMultiple */])(source.absorbers, (absorber) => {
                const tmp = new Absorber_Absorber();
                tmp.load(absorber);
                return tmp;
            });
        }
        options.interactivity.modes.absorbers = Object(esm["v" /* executeOnSingleOrMultiple */])((_b = (_a = source === null || source === void 0 ? void 0 : source.interactivity) === null || _a === void 0 ? void 0 : _a.modes) === null || _b === void 0 ? void 0 : _b.absorbers, (absorber) => {
            const tmp = new Absorber_Absorber();
            tmp.load(absorber);
            return tmp;
        });
    }
    needsPlugin(options) {
        var _a, _b, _c;
        if (!options) {
            return false;
        }
        const absorbers = options.absorbers;
        if (absorbers instanceof Array) {
            return !!absorbers.length;
        }
        else if (absorbers) {
            return true;
        }
        else if (((_c = (_b = (_a = options.interactivity) === null || _a === void 0 ? void 0 : _a.events) === null || _b === void 0 ? void 0 : _b.onClick) === null || _c === void 0 ? void 0 : _c.mode) &&
            Object(esm["K" /* isInArray */])("absorber", options.interactivity.events.onClick.mode)) {
            return true;
        }
        return false;
    }
}
async function loadAbsorbersPlugin(engine) {
    const plugin = new esm_AbsorbersPlugin();
    await engine.addPlugin(plugin);
}



// CONCATENATED MODULE: ./node_modules/tsparticles-updater-destroy/esm/Options/Classes/DestroyBounds.js

class DestroyBounds_DestroyBounds {
    load(data) {
        if (!data) {
            return;
        }
        if (data.bottom !== undefined) {
            this.bottom = Object(esm["Y" /* setRangeValue */])(data.bottom);
        }
        if (data.left !== undefined) {
            this.left = Object(esm["Y" /* setRangeValue */])(data.left);
        }
        if (data.right !== undefined) {
            this.right = Object(esm["Y" /* setRangeValue */])(data.right);
        }
        if (data.top !== undefined) {
            this.top = Object(esm["Y" /* setRangeValue */])(data.top);
        }
    }
}

// CONCATENATED MODULE: ./node_modules/tsparticles-updater-destroy/esm/Options/Classes/SplitFactor.js

class SplitFactor_SplitFactor extends esm["g" /* ValueWithRandom */] {
    constructor() {
        super();
        this.value = 3;
    }
}

// CONCATENATED MODULE: ./node_modules/tsparticles-updater-destroy/esm/Options/Classes/SplitRate.js

class SplitRate_SplitRate extends esm["g" /* ValueWithRandom */] {
    constructor() {
        super();
        this.value = { min: 4, max: 9 };
    }
}

// CONCATENATED MODULE: ./node_modules/tsparticles-updater-destroy/esm/Options/Classes/Split.js



class Split_Split {
    constructor() {
        this.count = 1;
        this.factor = new SplitFactor_SplitFactor();
        this.rate = new SplitRate_SplitRate();
        this.sizeOffset = true;
    }
    load(data) {
        var _a;
        if (!data) {
            return;
        }
        if (data.color !== undefined) {
            this.color = esm["d" /* OptionsColor */].create(this.color, data.color);
        }
        if (data.count !== undefined) {
            this.count = data.count;
        }
        this.factor.load(data.factor);
        this.rate.load(data.rate);
        this.particles = Object(esm["v" /* executeOnSingleOrMultiple */])(data.particles, (particles) => {
            return Object(esm["q" /* deepExtend */])({}, particles);
        });
        if (data.sizeOffset !== undefined) {
            this.sizeOffset = data.sizeOffset;
        }
        if (data.colorOffset) {
            this.colorOffset = (_a = this.colorOffset) !== null && _a !== void 0 ? _a : {};
            if (data.colorOffset.h !== undefined) {
                this.colorOffset.h = data.colorOffset.h;
            }
            if (data.colorOffset.s !== undefined) {
                this.colorOffset.s = data.colorOffset.s;
            }
            if (data.colorOffset.l !== undefined) {
                this.colorOffset.l = data.colorOffset.l;
            }
        }
    }
}

// CONCATENATED MODULE: ./node_modules/tsparticles-updater-destroy/esm/Options/Classes/Destroy.js


class Destroy_Destroy {
    constructor() {
        this.bounds = new DestroyBounds_DestroyBounds();
        this.mode = "none";
        this.split = new Split_Split();
    }
    load(data) {
        if (!data) {
            return;
        }
        if (data.mode) {
            this.mode = data.mode;
        }
        if (data.bounds) {
            this.bounds.load(data.bounds);
        }
        this.split.load(data.split);
    }
}

// CONCATENATED MODULE: ./node_modules/tsparticles-updater-destroy/esm/DestroyUpdater.js


class DestroyUpdater_DestroyUpdater {
    constructor(engine, container) {
        this.engine = engine;
        this.container = container;
    }
    init(particle) {
        const container = this.container, particlesOptions = particle.options, destroyOptions = particlesOptions.destroy;
        if (!destroyOptions) {
            return;
        }
        particle.splitCount = 0;
        const destroyBounds = destroyOptions.bounds;
        if (!particle.destroyBounds) {
            particle.destroyBounds = {};
        }
        if (destroyBounds.bottom) {
            particle.destroyBounds.bottom = (Object(esm["F" /* getRangeValue */])(destroyBounds.bottom) * container.canvas.size.height) / 100;
        }
        if (destroyBounds.left) {
            particle.destroyBounds.left = (Object(esm["F" /* getRangeValue */])(destroyBounds.left) * container.canvas.size.width) / 100;
        }
        if (destroyBounds.right) {
            particle.destroyBounds.right = (Object(esm["F" /* getRangeValue */])(destroyBounds.right) * container.canvas.size.width) / 100;
        }
        if (destroyBounds.top) {
            particle.destroyBounds.top = (Object(esm["F" /* getRangeValue */])(destroyBounds.top) * container.canvas.size.height) / 100;
        }
    }
    isEnabled(particle) {
        return !particle.destroyed;
    }
    loadOptions(options, ...sources) {
        if (!options.destroy) {
            options.destroy = new Destroy_Destroy();
        }
        for (const source of sources) {
            options.destroy.load(source === null || source === void 0 ? void 0 : source.destroy);
        }
    }
    particleDestroyed(particle, override) {
        if (override) {
            return;
        }
        const destroyOptions = particle.options.destroy;
        if (destroyOptions && destroyOptions.mode === "split") {
            this.split(particle);
        }
    }
    update(particle) {
        if (!this.isEnabled(particle)) {
            return;
        }
        const position = particle.getPosition(), bounds = particle.destroyBounds;
        if (!bounds) {
            return;
        }
        if ((bounds.bottom !== undefined && position.y >= bounds.bottom) ||
            (bounds.left !== undefined && position.x <= bounds.left) ||
            (bounds.right !== undefined && position.x >= bounds.right) ||
            (bounds.top !== undefined && position.y <= bounds.top)) {
            particle.destroy();
        }
    }
    addSplitParticle(parent, splitParticlesOptions) {
        var _a, _b, _c;
        const destroyOptions = parent.options.destroy;
        if (!destroyOptions) {
            return;
        }
        const splitOptions = destroyOptions.split, options = Object(esm["Q" /* loadParticlesOptions */])(this.engine, this.container, parent.options), factor = Object(esm["I" /* getValue */])(splitOptions.factor), parentColor = parent.getFillColor();
        if (splitOptions.color) {
            options.color.load(splitOptions.color);
        }
        else if (splitOptions.colorOffset && parentColor) {
            options.color.load({
                value: {
                    hsl: {
                        h: parentColor.h + Object(esm["F" /* getRangeValue */])((_a = splitOptions.colorOffset.h) !== null && _a !== void 0 ? _a : 0),
                        s: parentColor.s + Object(esm["F" /* getRangeValue */])((_b = splitOptions.colorOffset.s) !== null && _b !== void 0 ? _b : 0),
                        l: parentColor.l + Object(esm["F" /* getRangeValue */])((_c = splitOptions.colorOffset.l) !== null && _c !== void 0 ? _c : 0),
                    },
                },
            });
        }
        else {
            options.color.load({
                value: {
                    hsl: parent.getFillColor(),
                },
            });
        }
        options.move.load({
            center: {
                x: parent.position.x,
                y: parent.position.y,
                mode: "precise",
            },
        });
        if (typeof options.size.value === "number") {
            options.size.value /= factor;
        }
        else {
            options.size.value.min /= factor;
            options.size.value.max /= factor;
        }
        options.load(splitParticlesOptions);
        const offset = splitOptions.sizeOffset ? Object(esm["Y" /* setRangeValue */])(-parent.size.value, parent.size.value) : 0, position = {
            x: parent.position.x + Object(esm["T" /* randomInRange */])(offset),
            y: parent.position.y + Object(esm["T" /* randomInRange */])(offset),
        };
        return this.container.particles.addParticle(position, options, parent.group, (particle) => {
            var _a;
            if (particle.size.value < 0.5) {
                return false;
            }
            particle.velocity.length = Object(esm["T" /* randomInRange */])(Object(esm["Y" /* setRangeValue */])(parent.velocity.length, particle.velocity.length));
            particle.splitCount = ((_a = parent.splitCount) !== null && _a !== void 0 ? _a : 0) + 1;
            particle.unbreakable = true;
            setTimeout(() => {
                particle.unbreakable = false;
            }, 500);
            return true;
        });
    }
    split(particle) {
        const destroyOptions = particle.options.destroy;
        if (!destroyOptions) {
            return;
        }
        const splitOptions = destroyOptions.split;
        if (splitOptions.count >= 0 &&
            (particle.splitCount === undefined || particle.splitCount++ > splitOptions.count)) {
            return;
        }
        const rate = Object(esm["I" /* getValue */])(splitOptions.rate), particlesSplitOptions = Object(esm["O" /* itemFromSingleOrMultiple */])(splitOptions.particles);
        for (let i = 0; i < rate; i++) {
            this.addSplitParticle(particle, particlesSplitOptions);
        }
    }
}

// CONCATENATED MODULE: ./node_modules/tsparticles-updater-destroy/esm/index.js

async function loadDestroyUpdater(engine) {
    await engine.addParticleUpdater("destroy", (container) => new DestroyUpdater_DestroyUpdater(engine, container));
}

// CONCATENATED MODULE: ./node_modules/tsparticles-plugin-emitters/esm/Shapes/Circle/CircleShape.js

class CircleShape_CircleShape {
    randomPosition(position, size, fill) {
        const generateTheta = (x, y) => {
            const u = Object(esm["C" /* getRandom */])() / 4.0, theta = Math.atan((y / x) * Math.tan(2 * Math.PI * u)), v = Object(esm["C" /* getRandom */])();
            if (v < 0.25) {
                return theta;
            }
            else if (v < 0.5) {
                return Math.PI - theta;
            }
            else if (v < 0.75) {
                return Math.PI + theta;
            }
            else {
                return -theta;
            }
        }, radius = (x, y, theta) => (x * y) / Math.sqrt((y * Math.cos(theta)) ** 2 + (x * Math.sin(theta)) ** 2), [a, b] = [size.width / 2, size.height / 2], randomTheta = generateTheta(a, b), maxRadius = radius(a, b, randomTheta), randomRadius = fill ? maxRadius * Math.sqrt(Object(esm["C" /* getRandom */])()) : maxRadius;
        return {
            x: position.x + randomRadius * Math.cos(randomTheta),
            y: position.y + randomRadius * Math.sin(randomTheta),
        };
    }
}

// CONCATENATED MODULE: ./node_modules/tsparticles-plugin-emitters/esm/Options/Classes/EmitterLife.js
class EmitterLife {
    constructor() {
        this.wait = false;
    }
    load(data) {
        if (!data) {
            return;
        }
        if (data.count !== undefined) {
            this.count = data.count;
        }
        if (data.delay !== undefined) {
            this.delay = data.delay;
        }
        if (data.duration !== undefined) {
            this.duration = data.duration;
        }
        if (data.wait !== undefined) {
            this.wait = data.wait;
        }
    }
}

// CONCATENATED MODULE: ./node_modules/tsparticles-plugin-emitters/esm/Options/Classes/EmitterRate.js

class EmitterRate_EmitterRate {
    constructor() {
        this.quantity = 1;
        this.delay = 0.1;
    }
    load(data) {
        if (data === undefined) {
            return;
        }
        if (data.quantity !== undefined) {
            this.quantity = Object(esm["Y" /* setRangeValue */])(data.quantity);
        }
        if (data.delay !== undefined) {
            this.delay = Object(esm["Y" /* setRangeValue */])(data.delay);
        }
    }
}

// CONCATENATED MODULE: ./node_modules/tsparticles-plugin-emitters/esm/Options/Classes/EmitterSize.js
class EmitterSize {
    constructor() {
        this.mode = "percent";
        this.height = 0;
        this.width = 0;
    }
    load(data) {
        if (data === undefined) {
            return;
        }
        if (data.mode !== undefined) {
            this.mode = data.mode;
        }
        if (data.height !== undefined) {
            this.height = data.height;
        }
        if (data.width !== undefined) {
            this.width = data.width;
        }
    }
}

// CONCATENATED MODULE: ./node_modules/tsparticles-plugin-emitters/esm/Options/Classes/Emitter.js




class Emitter_Emitter {
    constructor() {
        this.autoPlay = true;
        this.fill = true;
        this.life = new EmitterLife();
        this.rate = new EmitterRate_EmitterRate();
        this.shape = "square";
        this.startCount = 0;
    }
    load(data) {
        if (!data) {
            return;
        }
        if (data.autoPlay !== undefined) {
            this.autoPlay = data.autoPlay;
        }
        if (data.size !== undefined) {
            if (!this.size) {
                this.size = new EmitterSize();
            }
            this.size.load(data.size);
        }
        if (data.direction !== undefined) {
            this.direction = data.direction;
        }
        this.domId = data.domId;
        if (data.fill !== undefined) {
            this.fill = data.fill;
        }
        this.life.load(data.life);
        this.name = data.name;
        this.particles = Object(esm["v" /* executeOnSingleOrMultiple */])(data.particles, (particles) => {
            return Object(esm["q" /* deepExtend */])({}, particles);
        });
        this.rate.load(data.rate);
        if (data.shape !== undefined) {
            this.shape = data.shape;
        }
        if (data.position !== undefined) {
            this.position = {};
            if (data.position.x !== undefined) {
                this.position.x = Object(esm["Y" /* setRangeValue */])(data.position.x);
            }
            if (data.position.y !== undefined) {
                this.position.y = Object(esm["Y" /* setRangeValue */])(data.position.y);
            }
        }
        if (data.spawnColor !== undefined) {
            if (this.spawnColor === undefined) {
                this.spawnColor = new esm["a" /* AnimatableColor */]();
            }
            this.spawnColor.load(data.spawnColor);
        }
        if (data.startCount !== undefined) {
            this.startCount = data.startCount;
        }
    }
}

// CONCATENATED MODULE: ./node_modules/tsparticles-plugin-emitters/esm/EmitterInstance.js



class EmitterInstance_EmitterInstance {
    constructor(engine, emitters, container, options, position) {
        var _a, _b, _c, _d, _e, _f, _g;
        var _h;
        this.emitters = emitters;
        this.container = container;
        this._engine = engine;
        this._currentDuration = 0;
        this._currentEmitDelay = 0;
        this._currentSpawnDelay = 0;
        this._initialPosition = position;
        if (options instanceof Emitter_Emitter) {
            this.options = options;
        }
        else {
            this.options = new Emitter_Emitter();
            this.options.load(options);
        }
        this._spawnDelay = (((_a = this.options.life.delay) !== null && _a !== void 0 ? _a : 0) * 1000) / this.container.retina.reduceFactor;
        this.position = (_b = this._initialPosition) !== null && _b !== void 0 ? _b : this.calcPosition();
        this.name = this.options.name;
        this._shape = (_c = this._engine.emitterShapeManager) === null || _c === void 0 ? void 0 : _c.getShape(this.options.shape);
        this.fill = this.options.fill;
        this._firstSpawn = !this.options.life.wait;
        this._startParticlesAdded = false;
        let particlesOptions = Object(esm["q" /* deepExtend */])({}, this.options.particles);
        particlesOptions !== null && particlesOptions !== void 0 ? particlesOptions : (particlesOptions = {});
        (_d = particlesOptions.move) !== null && _d !== void 0 ? _d : (particlesOptions.move = {});
        (_e = (_h = particlesOptions.move).direction) !== null && _e !== void 0 ? _e : (_h.direction = this.options.direction);
        if (this.options.spawnColor) {
            this.spawnColor = Object(esm["U" /* rangeColorToHsl */])(this.options.spawnColor);
        }
        this._paused = !this.options.autoPlay;
        this._particlesOptions = particlesOptions;
        this.size =
            (_f = this.options.size) !== null && _f !== void 0 ? _f : (() => {
                const size = new EmitterSize();
                size.load({
                    height: 0,
                    mode: "percent",
                    width: 0,
                });
                return size;
            })();
        this._lifeCount = (_g = this.options.life.count) !== null && _g !== void 0 ? _g : -1;
        this._immortal = this._lifeCount <= 0;
        this._engine.dispatchEvent("emitterCreated", {
            container,
            data: {
                emitter: this,
            },
        });
        this.play();
    }
    externalPause() {
        this._paused = true;
        this.pause();
    }
    externalPlay() {
        this._paused = false;
        this.play();
    }
    getPosition() {
        if (this.options.domId) {
            const container = this.container, element = document.getElementById(this.options.domId);
            if (element) {
                const elRect = element.getBoundingClientRect();
                return {
                    x: (elRect.x + elRect.width / 2) * container.retina.pixelRatio,
                    y: (elRect.y + elRect.height / 2) * container.retina.pixelRatio,
                };
            }
        }
        return this.position;
    }
    getSize() {
        const container = this.container;
        if (this.options.domId) {
            const element = document.getElementById(this.options.domId);
            if (element) {
                const elRect = element.getBoundingClientRect();
                return {
                    width: elRect.width * container.retina.pixelRatio,
                    height: elRect.height * container.retina.pixelRatio,
                };
            }
        }
        return {
            width: this.size.mode === "percent"
                ? (container.canvas.size.width * this.size.width) / 100
                : this.size.width,
            height: this.size.mode === "percent"
                ? (container.canvas.size.height * this.size.height) / 100
                : this.size.height,
        };
    }
    pause() {
        if (this._paused) {
            return;
        }
        delete this._emitDelay;
    }
    play() {
        var _a;
        if (this._paused) {
            return;
        }
        if (!(this.container.retina.reduceFactor &&
            (this._lifeCount > 0 || this._immortal || !this.options.life.count) &&
            (this._firstSpawn || this._currentSpawnDelay >= ((_a = this._spawnDelay) !== null && _a !== void 0 ? _a : 0)))) {
            return;
        }
        if (this._emitDelay === undefined) {
            const delay = Object(esm["F" /* getRangeValue */])(this.options.rate.delay);
            this._emitDelay = (1000 * delay) / this.container.retina.reduceFactor;
        }
        if (this._lifeCount > 0 || this._immortal) {
            this.prepareToDie();
        }
    }
    resize() {
        const initialPosition = this._initialPosition;
        this.position =
            initialPosition && Object(esm["L" /* isPointInside */])(initialPosition, this.container.canvas.size, esm["h" /* Vector */].origin)
                ? initialPosition
                : this.calcPosition();
    }
    update(delta) {
        var _a, _b, _c;
        if (this._paused) {
            return;
        }
        if (this._firstSpawn) {
            this._firstSpawn = false;
            this._currentSpawnDelay = (_a = this._spawnDelay) !== null && _a !== void 0 ? _a : 0;
            this._currentEmitDelay = (_b = this._emitDelay) !== null && _b !== void 0 ? _b : 0;
        }
        if (!this._startParticlesAdded) {
            this._startParticlesAdded = true;
            this.emitParticles(this.options.startCount);
        }
        if (this._duration !== undefined) {
            this._currentDuration += delta.value;
            if (this._currentDuration >= this._duration) {
                this.pause();
                if (this._spawnDelay !== undefined) {
                    delete this._spawnDelay;
                }
                if (!this._immortal) {
                    this._lifeCount--;
                }
                if (this._lifeCount > 0 || this._immortal) {
                    this.position = this.calcPosition();
                    this._spawnDelay = (((_c = this.options.life.delay) !== null && _c !== void 0 ? _c : 0) * 1000) / this.container.retina.reduceFactor;
                }
                else {
                    this.destroy();
                }
                this._currentDuration -= this._duration;
                delete this._duration;
            }
        }
        if (this._spawnDelay !== undefined) {
            this._currentSpawnDelay += delta.value;
            if (this._currentSpawnDelay >= this._spawnDelay) {
                this._engine.dispatchEvent("emitterPlay", {
                    container: this.container,
                });
                this.play();
                this._currentSpawnDelay -= this._currentSpawnDelay;
                delete this._spawnDelay;
            }
        }
        if (this._emitDelay !== undefined) {
            this._currentEmitDelay += delta.value;
            if (this._currentEmitDelay >= this._emitDelay) {
                this.emit();
                this._currentEmitDelay -= this._emitDelay;
            }
        }
    }
    calcPosition() {
        return Object(esm["k" /* calcPositionOrRandomFromSizeRanged */])({
            size: this.container.canvas.size,
            position: this.options.position,
        });
    }
    destroy() {
        this.emitters.removeEmitter(this);
        this._engine.dispatchEvent("emitterDestroyed", {
            container: this.container,
            data: {
                emitter: this,
            },
        });
    }
    emit() {
        if (this._paused) {
            return;
        }
        const quantity = Object(esm["F" /* getRangeValue */])(this.options.rate.quantity);
        this.emitParticles(quantity);
    }
    emitParticles(quantity) {
        var _a, _b, _c;
        const position = this.getPosition(), size = this.getSize(), singleParticlesOptions = Object(esm["O" /* itemFromSingleOrMultiple */])(this._particlesOptions);
        for (let i = 0; i < quantity; i++) {
            const particlesOptions = Object(esm["q" /* deepExtend */])({}, singleParticlesOptions);
            if (this.spawnColor) {
                const hslAnimation = (_a = this.options.spawnColor) === null || _a === void 0 ? void 0 : _a.animation;
                if (hslAnimation) {
                    this.spawnColor.h = this.setColorAnimation(hslAnimation.h, this.spawnColor.h, 360);
                    this.spawnColor.s = this.setColorAnimation(hslAnimation.s, this.spawnColor.s, 100);
                    this.spawnColor.l = this.setColorAnimation(hslAnimation.l, this.spawnColor.l, 100);
                }
                if (!particlesOptions.color) {
                    particlesOptions.color = {
                        value: this.spawnColor,
                    };
                }
                else {
                    particlesOptions.color.value = this.spawnColor;
                }
            }
            if (!position) {
                return;
            }
            const pPosition = (_c = (_b = this._shape) === null || _b === void 0 ? void 0 : _b.randomPosition(position, size, this.fill)) !== null && _c !== void 0 ? _c : position;
            this.container.particles.addParticle(pPosition, particlesOptions);
        }
    }
    prepareToDie() {
        var _a;
        if (this._paused) {
            return;
        }
        const duration = (_a = this.options.life) === null || _a === void 0 ? void 0 : _a.duration;
        if (this.container.retina.reduceFactor &&
            (this._lifeCount > 0 || this._immortal) &&
            duration !== undefined &&
            duration > 0) {
            this._duration = duration * 1000;
        }
    }
    setColorAnimation(animation, initValue, maxValue) {
        var _a;
        const container = this.container;
        if (!animation.enable) {
            return initValue;
        }
        const colorOffset = Object(esm["T" /* randomInRange */])(animation.offset), delay = Object(esm["F" /* getRangeValue */])(this.options.rate.delay), emitFactor = (1000 * delay) / container.retina.reduceFactor, colorSpeed = Object(esm["F" /* getRangeValue */])((_a = animation.speed) !== null && _a !== void 0 ? _a : 0);
        return (initValue + (colorSpeed * container.fpsLimit) / emitFactor + colorOffset * 3.6) % maxValue;
    }
}

// CONCATENATED MODULE: ./node_modules/tsparticles-plugin-emitters/esm/Emitters.js



class Emitters_Emitters {
    constructor(engine, container) {
        this.container = container;
        this._engine = engine;
        this.array = [];
        this.emitters = [];
        this.interactivityEmitters = {
            random: {
                count: 1,
                enable: false,
            },
            value: [],
        };
        container.getEmitter = (idxOrName) => idxOrName === undefined || typeof idxOrName === "number"
            ? this.array[idxOrName || 0]
            : this.array.find((t) => t.name === idxOrName);
        container.addEmitter = (options, position) => this.addEmitter(options, position);
        container.removeEmitter = (idxOrName) => {
            const emitter = container.getEmitter(idxOrName);
            if (emitter) {
                this.removeEmitter(emitter);
            }
        };
        container.playEmitter = (idxOrName) => {
            const emitter = container.getEmitter(idxOrName);
            if (emitter) {
                emitter.externalPlay();
            }
        };
        container.pauseEmitter = (idxOrName) => {
            const emitter = container.getEmitter(idxOrName);
            if (emitter) {
                emitter.externalPause();
            }
        };
    }
    addEmitter(options, position) {
        const emitterOptions = new Emitter_Emitter();
        emitterOptions.load(options);
        const emitter = new EmitterInstance_EmitterInstance(this._engine, this, this.container, emitterOptions, position);
        this.array.push(emitter);
        return emitter;
    }
    handleClickMode(mode) {
        const emitterOptions = this.emitters, modeEmitters = this.interactivityEmitters;
        if (mode !== "emitter") {
            return;
        }
        let emittersModeOptions;
        if (modeEmitters && modeEmitters.value instanceof Array) {
            if (modeEmitters.value.length > 0 && modeEmitters.random.enable) {
                emittersModeOptions = [];
                const usedIndexes = [];
                for (let i = 0; i < modeEmitters.random.count; i++) {
                    const idx = Object(esm["i" /* arrayRandomIndex */])(modeEmitters.value);
                    if (usedIndexes.includes(idx) && usedIndexes.length < modeEmitters.value.length) {
                        i--;
                        continue;
                    }
                    usedIndexes.push(idx);
                    emittersModeOptions.push(Object(esm["N" /* itemFromArray */])(modeEmitters.value, idx));
                }
            }
            else {
                emittersModeOptions = modeEmitters.value;
            }
        }
        else {
            emittersModeOptions = modeEmitters === null || modeEmitters === void 0 ? void 0 : modeEmitters.value;
        }
        const emittersOptions = emittersModeOptions !== null && emittersModeOptions !== void 0 ? emittersModeOptions : emitterOptions, ePosition = this.container.interactivity.mouse.clickPosition;
        Object(esm["v" /* executeOnSingleOrMultiple */])(emittersOptions, (emitter) => {
            this.addEmitter(emitter, ePosition);
        });
    }
    async init() {
        this.emitters = this.container.actualOptions.emitters;
        this.interactivityEmitters = this.container.actualOptions.interactivity.modes.emitters;
        if (!this.emitters) {
            return;
        }
        if (this.emitters instanceof Array) {
            for (const emitterOptions of this.emitters) {
                this.addEmitter(emitterOptions);
            }
        }
        else {
            this.addEmitter(this.emitters);
        }
    }
    pause() {
        for (const emitter of this.array) {
            emitter.pause();
        }
    }
    play() {
        for (const emitter of this.array) {
            emitter.play();
        }
    }
    removeEmitter(emitter) {
        const index = this.array.indexOf(emitter);
        if (index >= 0) {
            this.array.splice(index, 1);
        }
    }
    resize() {
        for (const emitter of this.array) {
            emitter.resize();
        }
    }
    stop() {
        this.array = [];
    }
    update(delta) {
        for (const emitter of this.array) {
            emitter.update(delta);
        }
    }
}

// CONCATENATED MODULE: ./node_modules/tsparticles-plugin-emitters/esm/ShapeManager.js
const shapes = new Map();
class ShapeManager {
    constructor(engine) {
        this._engine = engine;
    }
    addShape(name, drawer) {
        if (!this.getShape(name)) {
            shapes.set(name, drawer);
        }
    }
    getShape(name) {
        return shapes.get(name);
    }
    getSupportedShapes() {
        return shapes.keys();
    }
}

// CONCATENATED MODULE: ./node_modules/tsparticles-plugin-emitters/esm/Shapes/Square/SquareShape.js

function randomSquareCoordinate(position, offset) {
    return position + offset * (Object(esm["C" /* getRandom */])() - 0.5);
}
class SquareShape_SquareShape {
    randomPosition(position, size, fill) {
        if (fill) {
            return {
                x: randomSquareCoordinate(position.x, size.width),
                y: randomSquareCoordinate(position.y, size.height),
            };
        }
        else {
            const halfW = size.width / 2, halfH = size.height / 2, side = Math.floor(Object(esm["C" /* getRandom */])() * 4), v = (Object(esm["C" /* getRandom */])() - 0.5) * 2;
            switch (side) {
                case 0:
                    return {
                        x: position.x + v * halfW,
                        y: position.y - halfH,
                    };
                case 1:
                    return {
                        x: position.x - halfW,
                        y: position.y + v * halfH,
                    };
                case 2:
                    return {
                        x: position.x + v * halfW,
                        y: position.y + halfH,
                    };
                case 3:
                default:
                    return {
                        x: position.x + halfW,
                        y: position.y + v * halfH,
                    };
            }
        }
    }
}

// CONCATENATED MODULE: ./node_modules/tsparticles-plugin-emitters/esm/EmitterContainer.js


// CONCATENATED MODULE: ./node_modules/tsparticles-plugin-emitters/esm/EmittersEngine.js


// CONCATENATED MODULE: ./node_modules/tsparticles-plugin-emitters/esm/Enums/EmitterClickMode.js


// CONCATENATED MODULE: ./node_modules/tsparticles-plugin-emitters/esm/Enums/EmitterShapeType.js


// CONCATENATED MODULE: ./node_modules/tsparticles-plugin-emitters/esm/index.js






class esm_EmittersPlugin {
    constructor(engine) {
        this._engine = engine;
        this.id = "emitters";
    }
    getPlugin(container) {
        return new Emitters_Emitters(this._engine, container);
    }
    loadOptions(options, source) {
        var _a, _b, _c, _d, _e, _f;
        if (!this.needsPlugin(options) && !this.needsPlugin(source)) {
            return;
        }
        if (source === null || source === void 0 ? void 0 : source.emitters) {
            options.emitters = Object(esm["v" /* executeOnSingleOrMultiple */])(source.emitters, (emitter) => {
                const tmp = new Emitter_Emitter();
                tmp.load(emitter);
                return tmp;
            });
        }
        const interactivityEmitters = (_b = (_a = source === null || source === void 0 ? void 0 : source.interactivity) === null || _a === void 0 ? void 0 : _a.modes) === null || _b === void 0 ? void 0 : _b.emitters;
        if (interactivityEmitters) {
            if (interactivityEmitters instanceof Array) {
                options.interactivity.modes.emitters = {
                    random: {
                        count: 1,
                        enable: true,
                    },
                    value: interactivityEmitters.map((s) => {
                        const tmp = new Emitter_Emitter();
                        tmp.load(s);
                        return tmp;
                    }),
                };
            }
            else {
                const emitterMode = interactivityEmitters;
                if (emitterMode.value !== undefined) {
                    if (emitterMode.value instanceof Array) {
                        options.interactivity.modes.emitters = {
                            random: {
                                count: (_c = emitterMode.random.count) !== null && _c !== void 0 ? _c : 1,
                                enable: (_d = emitterMode.random.enable) !== null && _d !== void 0 ? _d : false,
                            },
                            value: emitterMode.value.map((s) => {
                                const tmp = new Emitter_Emitter();
                                tmp.load(s);
                                return tmp;
                            }),
                        };
                    }
                    else {
                        const tmp = new Emitter_Emitter();
                        tmp.load(emitterMode.value);
                        options.interactivity.modes.emitters = {
                            random: {
                                count: (_e = emitterMode.random.count) !== null && _e !== void 0 ? _e : 1,
                                enable: (_f = emitterMode.random.enable) !== null && _f !== void 0 ? _f : false,
                            },
                            value: tmp,
                        };
                    }
                }
                else {
                    const emitterOptions = (options.interactivity.modes.emitters = {
                        random: {
                            count: 1,
                            enable: false,
                        },
                        value: new Emitter_Emitter(),
                    });
                    emitterOptions.value.load(interactivityEmitters);
                }
            }
        }
    }
    needsPlugin(options) {
        var _a, _b, _c;
        if (!options) {
            return false;
        }
        const emitters = options.emitters;
        return ((emitters instanceof Array && !!emitters.length) ||
            emitters !== undefined ||
            (!!((_c = (_b = (_a = options.interactivity) === null || _a === void 0 ? void 0 : _a.events) === null || _b === void 0 ? void 0 : _b.onClick) === null || _c === void 0 ? void 0 : _c.mode) &&
                Object(esm["K" /* isInArray */])("emitter", options.interactivity.events.onClick.mode)));
    }
}
async function loadEmittersPlugin(engine) {
    if (!engine.emitterShapeManager) {
        engine.emitterShapeManager = new ShapeManager(engine);
    }
    if (!engine.addEmitterShape) {
        engine.addEmitterShape = (name, shape) => {
            var _a;
            (_a = engine.emitterShapeManager) === null || _a === void 0 ? void 0 : _a.addShape(name, shape);
        };
    }
    const plugin = new esm_EmittersPlugin(engine);
    await engine.addPlugin(plugin);
    engine.addEmitterShape("circle", new CircleShape_CircleShape());
    engine.addEmitterShape("square", new SquareShape_SquareShape());
}





// CONCATENATED MODULE: ./node_modules/tsparticles-interaction-external-trail/esm/Options/Classes/Trail.js

class Trail_Trail {
    constructor() {
        this.delay = 1;
        this.pauseOnStop = false;
        this.quantity = 1;
    }
    load(data) {
        if (!data) {
            return;
        }
        if (data.delay !== undefined) {
            this.delay = data.delay;
        }
        if (data.quantity !== undefined) {
            this.quantity = data.quantity;
        }
        if (data.particles !== undefined) {
            this.particles = Object(esm["q" /* deepExtend */])({}, data.particles);
        }
        if (data.pauseOnStop !== undefined) {
            this.pauseOnStop = data.pauseOnStop;
        }
    }
}

// CONCATENATED MODULE: ./node_modules/tsparticles-interaction-external-trail/esm/TrailMaker.js


class TrailMaker_TrailMaker extends esm["c" /* ExternalInteractorBase */] {
    constructor(container) {
        super(container);
        this._delay = 0;
    }
    clear() {
    }
    init() {
    }
    async interact(delta) {
        var _a, _b, _c, _d;
        if (!this.container.retina.reduceFactor) {
            return;
        }
        const container = this.container, options = container.actualOptions, trailOptions = options.interactivity.modes.trail;
        if (!trailOptions) {
            return;
        }
        const optDelay = (trailOptions.delay * 1000) / this.container.retina.reduceFactor;
        if (this._delay < optDelay) {
            this._delay += delta.value;
        }
        if (this._delay < optDelay) {
            return;
        }
        let canEmit = true;
        if (trailOptions.pauseOnStop) {
            if (container.interactivity.mouse.position === this._lastPosition ||
                (((_a = container.interactivity.mouse.position) === null || _a === void 0 ? void 0 : _a.x) === ((_b = this._lastPosition) === null || _b === void 0 ? void 0 : _b.x) &&
                    ((_c = container.interactivity.mouse.position) === null || _c === void 0 ? void 0 : _c.y) === ((_d = this._lastPosition) === null || _d === void 0 ? void 0 : _d.y))) {
                canEmit = false;
            }
        }
        if (container.interactivity.mouse.position) {
            this._lastPosition = {
                x: container.interactivity.mouse.position.x,
                y: container.interactivity.mouse.position.y,
            };
        }
        else {
            delete this._lastPosition;
        }
        if (canEmit) {
            container.particles.push(trailOptions.quantity, container.interactivity.mouse, trailOptions.particles);
        }
        this._delay -= optDelay;
    }
    isEnabled(particle) {
        var _a;
        const container = this.container, options = container.actualOptions, mouse = container.interactivity.mouse, events = ((_a = particle === null || particle === void 0 ? void 0 : particle.interactivity) !== null && _a !== void 0 ? _a : options.interactivity).events;
        return ((mouse.clicking && mouse.inside && !!mouse.position && Object(esm["K" /* isInArray */])("trail", events.onClick.mode)) ||
            (mouse.inside && !!mouse.position && Object(esm["K" /* isInArray */])("trail", events.onHover.mode)));
    }
    loadModeOptions(options, ...sources) {
        if (!options.trail) {
            options.trail = new Trail_Trail();
        }
        for (const source of sources) {
            options.trail.load(source === null || source === void 0 ? void 0 : source.trail);
        }
    }
    reset() {
    }
}

// CONCATENATED MODULE: ./node_modules/tsparticles-interaction-external-trail/esm/Options/Interfaces/ITrail.js


// CONCATENATED MODULE: ./node_modules/tsparticles-interaction-external-trail/esm/index.js

async function loadExternalTrailInteraction(engine) {
    await engine.addInteractor("externalTrail", (container) => new TrailMaker_TrailMaker(container));
}



// CONCATENATED MODULE: ./node_modules/tsparticles-updater-roll/esm/Options/Classes/RollLight.js

class RollLight_RollLight {
    constructor() {
        this.enable = false;
        this.value = 0;
    }
    load(data) {
        if (!data) {
            return;
        }
        if (data.enable !== undefined) {
            this.enable = data.enable;
        }
        if (data.value !== undefined) {
            this.value = Object(esm["Y" /* setRangeValue */])(data.value);
        }
    }
}

// CONCATENATED MODULE: ./node_modules/tsparticles-updater-roll/esm/Options/Classes/Roll.js


class Roll_Roll {
    constructor() {
        this.darken = new RollLight_RollLight();
        this.enable = false;
        this.enlighten = new RollLight_RollLight();
        this.mode = "vertical";
        this.speed = 25;
    }
    load(data) {
        if (!data) {
            return;
        }
        if (data.backColor !== undefined) {
            this.backColor = esm["d" /* OptionsColor */].create(this.backColor, data.backColor);
        }
        this.darken.load(data.darken);
        if (data.enable !== undefined) {
            this.enable = data.enable;
        }
        this.enlighten.load(data.enlighten);
        if (data.mode !== undefined) {
            this.mode = data.mode;
        }
        if (data.speed !== undefined) {
            this.speed = Object(esm["Y" /* setRangeValue */])(data.speed);
        }
    }
}

// CONCATENATED MODULE: ./node_modules/tsparticles-updater-roll/esm/RollUpdater.js


function updateRoll(particle, delta) {
    const roll = particle.options.roll;
    if (!particle.roll || !(roll === null || roll === void 0 ? void 0 : roll.enable)) {
        return;
    }
    const speed = particle.roll.speed * delta.factor, max = 2 * Math.PI;
    particle.roll.angle += speed;
    if (particle.roll.angle > max) {
        particle.roll.angle -= max;
    }
}
class RollUpdater_RollUpdater {
    getTransformValues(particle) {
        var _a;
        const roll = ((_a = particle.roll) === null || _a === void 0 ? void 0 : _a.enable) && particle.roll, rollHorizontal = roll && roll.horizontal, rollVertical = roll && roll.vertical;
        return {
            a: rollHorizontal ? Math.cos(roll.angle) : undefined,
            d: rollVertical ? Math.sin(roll.angle) : undefined,
        };
    }
    init(particle) {
        const rollOpt = particle.options.roll;
        if (rollOpt === null || rollOpt === void 0 ? void 0 : rollOpt.enable) {
            particle.roll = {
                enable: rollOpt.enable,
                horizontal: rollOpt.mode === "horizontal" || rollOpt.mode === "both",
                vertical: rollOpt.mode === "vertical" || rollOpt.mode === "both",
                angle: Object(esm["C" /* getRandom */])() * Math.PI * 2,
                speed: Object(esm["F" /* getRangeValue */])(rollOpt.speed) / 360,
            };
            if (rollOpt.backColor) {
                particle.backColor = Object(esm["U" /* rangeColorToHsl */])(rollOpt.backColor);
            }
            else if (rollOpt.darken.enable && rollOpt.enlighten.enable) {
                const alterType = Object(esm["C" /* getRandom */])() >= 0.5 ? "darken" : "enlighten";
                particle.roll.alter = {
                    type: alterType,
                    value: Object(esm["F" /* getRangeValue */])(alterType === "darken" ? rollOpt.darken.value : rollOpt.enlighten.value),
                };
            }
            else if (rollOpt.darken.enable) {
                particle.roll.alter = {
                    type: "darken",
                    value: Object(esm["F" /* getRangeValue */])(rollOpt.darken.value),
                };
            }
            else if (rollOpt.enlighten.enable) {
                particle.roll.alter = {
                    type: "enlighten",
                    value: Object(esm["F" /* getRangeValue */])(rollOpt.enlighten.value),
                };
            }
        }
        else {
            particle.roll = {
                enable: false,
                horizontal: false,
                vertical: false,
                angle: 0,
                speed: 0,
            };
        }
    }
    isEnabled(particle) {
        const roll = particle.options.roll;
        return !particle.destroyed && !particle.spawning && !!(roll === null || roll === void 0 ? void 0 : roll.enable);
    }
    loadOptions(options, ...sources) {
        if (!options.roll) {
            options.roll = new Roll_Roll();
        }
        for (const source of sources) {
            options.roll.load(source === null || source === void 0 ? void 0 : source.roll);
        }
    }
    update(particle, delta) {
        if (!this.isEnabled(particle)) {
            return;
        }
        updateRoll(particle, delta);
    }
}

// CONCATENATED MODULE: ./node_modules/tsparticles-updater-roll/esm/index.js

async function loadRollUpdater(engine) {
    await engine.addParticleUpdater("roll", () => new RollUpdater_RollUpdater());
}

// CONCATENATED MODULE: ./node_modules/tsparticles-particles.js/esm/index.js
const initPjs = (engine) => {
    const particlesJS = (tagId, options) => {
        return engine.load(tagId, options);
    };
    particlesJS.load = (tagId, pathConfigJson, callback) => {
        engine
            .loadJSON(tagId, pathConfigJson)
            .then((container) => {
            if (container) {
                callback(container);
            }
        })
            .catch(() => {
            callback(undefined);
        });
    };
    particlesJS.setOnClickHandler = (callback) => {
        engine.setOnClickHandler(callback);
    };
    const pJSDom = engine.dom();
    return { particlesJS, pJSDom };
};


// CONCATENATED MODULE: ./node_modules/tsparticles-updater-angle/esm/Options/Classes/RotateAnimation.js

class RotateAnimation_RotateAnimation {
    constructor() {
        this.enable = false;
        this.speed = 0;
        this.decay = 0;
        this.sync = false;
    }
    load(data) {
        if (!data) {
            return;
        }
        if (data.enable !== undefined) {
            this.enable = data.enable;
        }
        if (data.speed !== undefined) {
            this.speed = Object(esm["Y" /* setRangeValue */])(data.speed);
        }
        if (data.decay !== undefined) {
            this.decay = Object(esm["Y" /* setRangeValue */])(data.decay);
        }
        if (data.sync !== undefined) {
            this.sync = data.sync;
        }
    }
}

// CONCATENATED MODULE: ./node_modules/tsparticles-updater-angle/esm/Options/Classes/Rotate.js


class Rotate_Rotate extends esm["g" /* ValueWithRandom */] {
    constructor() {
        super();
        this.animation = new RotateAnimation_RotateAnimation();
        this.direction = "clockwise";
        this.path = false;
        this.value = 0;
    }
    load(data) {
        if (!data) {
            return;
        }
        super.load(data);
        if (data.direction !== undefined) {
            this.direction = data.direction;
        }
        this.animation.load(data.animation);
        if (data.path !== undefined) {
            this.path = data.path;
        }
    }
}

// CONCATENATED MODULE: ./node_modules/tsparticles-updater-angle/esm/RotateUpdater.js


function updateAngle(particle, delta) {
    var _a, _b;
    const rotate = particle.rotate, rotateOptions = particle.options.rotate;
    if (!rotate || !rotateOptions) {
        return;
    }
    const rotateAnimation = rotateOptions.animation, speed = ((_a = rotate.velocity) !== null && _a !== void 0 ? _a : 0) * delta.factor, max = 2 * Math.PI, decay = (_b = rotate.decay) !== null && _b !== void 0 ? _b : 1;
    if (!rotateAnimation.enable) {
        return;
    }
    switch (rotate.status) {
        case "increasing":
            rotate.value += speed;
            if (rotate.value > max) {
                rotate.value -= max;
            }
            break;
        case "decreasing":
        default:
            rotate.value -= speed;
            if (rotate.value < 0) {
                rotate.value += max;
            }
            break;
    }
    if (rotate.velocity && decay !== 1) {
        rotate.velocity *= decay;
    }
}
class RotateUpdater_RotateUpdater {
    constructor(container) {
        this.container = container;
    }
    init(particle) {
        const rotateOptions = particle.options.rotate;
        if (!rotateOptions) {
            return;
        }
        particle.rotate = {
            enable: rotateOptions.animation.enable,
            value: (Object(esm["F" /* getRangeValue */])(rotateOptions.value) * Math.PI) / 180,
        };
        particle.pathRotation = rotateOptions.path;
        let rotateDirection = rotateOptions.direction;
        if (rotateDirection === "random") {
            const index = Math.floor(Object(esm["C" /* getRandom */])() * 2);
            rotateDirection = index > 0 ? "counter-clockwise" : "clockwise";
        }
        switch (rotateDirection) {
            case "counter-clockwise":
            case "counterClockwise":
                particle.rotate.status = "decreasing";
                break;
            case "clockwise":
                particle.rotate.status = "increasing";
                break;
        }
        const rotateAnimation = rotateOptions.animation;
        if (rotateAnimation.enable) {
            particle.rotate.decay = 1 - Object(esm["F" /* getRangeValue */])(rotateAnimation.decay);
            particle.rotate.velocity =
                (Object(esm["F" /* getRangeValue */])(rotateAnimation.speed) / 360) * this.container.retina.reduceFactor;
            if (!rotateAnimation.sync) {
                particle.rotate.velocity *= Object(esm["C" /* getRandom */])();
            }
        }
        particle.rotation = particle.rotate.value;
    }
    isEnabled(particle) {
        const rotate = particle.options.rotate;
        if (!rotate) {
            return false;
        }
        return !particle.destroyed && !particle.spawning && rotate.animation.enable && !rotate.path;
    }
    loadOptions(options, ...sources) {
        if (!options.rotate) {
            options.rotate = new Rotate_Rotate();
        }
        for (const source of sources) {
            options.rotate.load(source === null || source === void 0 ? void 0 : source.rotate);
        }
    }
    update(particle, delta) {
        var _a, _b;
        if (!this.isEnabled(particle)) {
            return;
        }
        updateAngle(particle, delta);
        particle.rotation = (_b = (_a = particle.rotate) === null || _a === void 0 ? void 0 : _a.value) !== null && _b !== void 0 ? _b : 0;
    }
}

// CONCATENATED MODULE: ./node_modules/tsparticles-updater-angle/esm/index.js

async function loadAngleUpdater(engine) {
    await engine.addParticleUpdater("rotate", (container) => new RotateUpdater_RotateUpdater(container));
}

// CONCATENATED MODULE: ./node_modules/tsparticles-move-base/esm/Utils.js

function applyDistance(particle) {
    const initialPosition = particle.initialPosition, { dx, dy } = Object(esm["x" /* getDistances */])(initialPosition, particle.position), dxFixed = Math.abs(dx), dyFixed = Math.abs(dy), hDistance = particle.retina.maxDistance.horizontal, vDistance = particle.retina.maxDistance.vertical;
    if (!hDistance && !vDistance) {
        return;
    }
    if (((hDistance && dxFixed >= hDistance) || (vDistance && dyFixed >= vDistance)) && !particle.misplaced) {
        particle.misplaced = (!!hDistance && dxFixed > hDistance) || (!!vDistance && dyFixed > vDistance);
        if (hDistance) {
            particle.velocity.x = particle.velocity.y / 2 - particle.velocity.x;
        }
        if (vDistance) {
            particle.velocity.y = particle.velocity.x / 2 - particle.velocity.y;
        }
    }
    else if ((!hDistance || dxFixed < hDistance) && (!vDistance || dyFixed < vDistance) && particle.misplaced) {
        particle.misplaced = false;
    }
    else if (particle.misplaced) {
        const pos = particle.position, vel = particle.velocity;
        if (hDistance && ((pos.x < initialPosition.x && vel.x < 0) || (pos.x > initialPosition.x && vel.x > 0))) {
            vel.x *= -Object(esm["C" /* getRandom */])();
        }
        if (vDistance && ((pos.y < initialPosition.y && vel.y < 0) || (pos.y > initialPosition.y && vel.y > 0))) {
            vel.y *= -Object(esm["C" /* getRandom */])();
        }
    }
}
function spin(particle, moveSpeed) {
    const container = particle.container;
    if (!particle.spin) {
        return;
    }
    const updateFunc = {
        x: particle.spin.direction === "clockwise" ? Math.cos : Math.sin,
        y: particle.spin.direction === "clockwise" ? Math.sin : Math.cos,
    };
    particle.position.x = particle.spin.center.x + particle.spin.radius * updateFunc.x(particle.spin.angle);
    particle.position.y = particle.spin.center.y + particle.spin.radius * updateFunc.y(particle.spin.angle);
    particle.spin.radius += particle.spin.acceleration;
    const maxCanvasSize = Math.max(container.canvas.size.width, container.canvas.size.height);
    if (particle.spin.radius > maxCanvasSize / 2) {
        particle.spin.radius = maxCanvasSize / 2;
        particle.spin.acceleration *= -1;
    }
    else if (particle.spin.radius < 0) {
        particle.spin.radius = 0;
        particle.spin.acceleration *= -1;
    }
    particle.spin.angle += (moveSpeed / 100) * (1 - particle.spin.radius / maxCanvasSize);
}
function applyPath(particle, delta) {
    var _a;
    const particlesOptions = particle.options, pathOptions = particlesOptions.move.path, pathEnabled = pathOptions.enable;
    if (!pathEnabled) {
        return;
    }
    if (particle.lastPathTime <= particle.pathDelay) {
        particle.lastPathTime += delta.value;
        return;
    }
    const path = (_a = particle.pathGenerator) === null || _a === void 0 ? void 0 : _a.generate(particle);
    if (path) {
        particle.velocity.addTo(path);
    }
    if (pathOptions.clamp) {
        particle.velocity.x = Object(esm["o" /* clamp */])(particle.velocity.x, -1, 1);
        particle.velocity.y = Object(esm["o" /* clamp */])(particle.velocity.y, -1, 1);
    }
    particle.lastPathTime -= particle.pathDelay;
}
function getProximitySpeedFactor(particle) {
    return particle.slow.inRange ? particle.slow.factor : 1;
}

// CONCATENATED MODULE: ./node_modules/tsparticles-move-base/esm/BaseMover.js


class BaseMover_BaseMover {
    init(particle) {
        var _a;
        const container = particle.container, options = particle.options, gravityOptions = options.move.gravity, spinOptions = options.move.spin;
        particle.gravity = {
            enable: gravityOptions.enable,
            acceleration: Object(esm["F" /* getRangeValue */])(gravityOptions.acceleration),
            inverse: gravityOptions.inverse,
        };
        if (spinOptions.enable) {
            const spinPos = (_a = spinOptions.position) !== null && _a !== void 0 ? _a : { x: 50, y: 50 }, spinCenter = {
                x: (spinPos.x / 100) * container.canvas.size.width,
                y: (spinPos.y / 100) * container.canvas.size.height,
            }, pos = particle.getPosition(), distance = Object(esm["w" /* getDistance */])(pos, spinCenter), spinAcceleration = Object(esm["F" /* getRangeValue */])(spinOptions.acceleration);
            particle.retina.spinAcceleration = spinAcceleration * container.retina.pixelRatio;
            particle.spin = {
                center: spinCenter,
                direction: particle.velocity.x >= 0 ? "clockwise" : "counter-clockwise",
                angle: particle.velocity.angle,
                radius: distance,
                acceleration: particle.retina.spinAcceleration,
            };
        }
    }
    isEnabled(particle) {
        return !particle.destroyed && particle.options.move.enable;
    }
    move(particle, delta) {
        var _a, _b, _c;
        var _d, _e;
        const particleOptions = particle.options, moveOptions = particleOptions.move;
        if (!moveOptions.enable) {
            return;
        }
        const container = particle.container, slowFactor = getProximitySpeedFactor(particle), baseSpeed = ((_a = (_d = particle.retina).moveSpeed) !== null && _a !== void 0 ? _a : (_d.moveSpeed = Object(esm["F" /* getRangeValue */])(moveOptions.speed) * container.retina.pixelRatio)) *
            container.retina.reduceFactor, moveDrift = ((_b = (_e = particle.retina).moveDrift) !== null && _b !== void 0 ? _b : (_e.moveDrift = Object(esm["F" /* getRangeValue */])(particle.options.move.drift) * container.retina.pixelRatio)), maxSize = Object(esm["D" /* getRangeMax */])(particleOptions.size.value) * container.retina.pixelRatio, sizeFactor = moveOptions.size ? particle.getRadius() / maxSize : 1, speedFactor = sizeFactor * slowFactor * (delta.factor || 1), diffFactor = 2, moveSpeed = (baseSpeed * speedFactor) / diffFactor;
        if (moveOptions.spin.enable) {
            spin(particle, moveSpeed);
        }
        else {
            applyPath(particle, delta);
            const gravityOptions = particle.gravity, gravityFactor = (gravityOptions === null || gravityOptions === void 0 ? void 0 : gravityOptions.enable) && gravityOptions.inverse ? -1 : 1;
            if ((gravityOptions === null || gravityOptions === void 0 ? void 0 : gravityOptions.enable) && moveSpeed) {
                particle.velocity.y +=
                    (gravityFactor * (gravityOptions.acceleration * delta.factor)) / (60 * moveSpeed);
            }
            if (moveDrift && moveSpeed) {
                particle.velocity.x += (moveDrift * delta.factor) / (60 * moveSpeed);
            }
            const decay = particle.moveDecay;
            if (decay != 1) {
                particle.velocity.multTo(decay);
            }
            const velocity = particle.velocity.mult(moveSpeed), maxSpeed = (_c = particle.retina.maxSpeed) !== null && _c !== void 0 ? _c : container.retina.maxSpeed;
            if ((gravityOptions === null || gravityOptions === void 0 ? void 0 : gravityOptions.enable) &&
                maxSpeed > 0 &&
                ((!gravityOptions.inverse && velocity.y >= 0 && velocity.y >= maxSpeed) ||
                    (gravityOptions.inverse && velocity.y <= 0 && velocity.y <= -maxSpeed))) {
                velocity.y = gravityFactor * maxSpeed;
                if (moveSpeed) {
                    particle.velocity.y = velocity.y / moveSpeed;
                }
            }
            const zIndexOptions = particle.options.zIndex, zVelocityFactor = (1 - particle.zIndexFactor) ** zIndexOptions.velocityRate;
            if (zVelocityFactor != 1) {
                velocity.multTo(zVelocityFactor);
            }
            particle.position.addTo(velocity);
            if (moveOptions.vibrate) {
                particle.position.x += Math.sin(particle.position.x * Math.cos(particle.position.y));
                particle.position.y += Math.cos(particle.position.y * Math.sin(particle.position.x));
            }
        }
        applyDistance(particle);
    }
}

// CONCATENATED MODULE: ./node_modules/tsparticles-move-base/esm/index.js

async function loadBaseMover(engine) {
    engine.addMover("base", () => new BaseMover_BaseMover());
}

// CONCATENATED MODULE: ./node_modules/tsparticles-shape-circle/esm/CircleDrawer.js
class CircleDrawer {
    draw(context, particle, radius) {
        if (!particle.circleRange) {
            particle.circleRange = { min: 0, max: Math.PI * 2 };
        }
        const circleRange = particle.circleRange;
        context.arc(0, 0, radius, circleRange.min, circleRange.max, false);
    }
    getSidesCount() {
        return 12;
    }
    particleInit(container, particle) {
        var _a;
        const shapeData = particle.shapeData, angle = (_a = shapeData === null || shapeData === void 0 ? void 0 : shapeData.angle) !== null && _a !== void 0 ? _a : {
            max: 360,
            min: 0,
        };
        particle.circleRange =
            typeof angle !== "object"
                ? {
                    min: 0,
                    max: (angle * Math.PI) / 180,
                }
                : { min: (angle.min * Math.PI) / 180, max: (angle.max * Math.PI) / 180 };
    }
}

// CONCATENATED MODULE: ./node_modules/tsparticles-shape-circle/esm/index.js

async function loadCircleShape(engine) {
    await engine.addShape("circle", new CircleDrawer());
}

// CONCATENATED MODULE: ./node_modules/tsparticles-updater-color/esm/ColorUpdater.js

function updateColorValue(delta, value, valueAnimation, max, decrease) {
    var _a, _b;
    const colorValue = value;
    if (!colorValue ||
        !valueAnimation.enable ||
        (colorValue.loops !== undefined &&
            colorValue.maxLoops !== undefined &&
            colorValue.maxLoops > 0 &&
            colorValue.loops >= colorValue.maxLoops)) {
        return;
    }
    const offset = Object(esm["T" /* randomInRange */])(valueAnimation.offset), velocity = ((_a = value.velocity) !== null && _a !== void 0 ? _a : 0) * delta.factor + offset * 3.6, decay = (_b = value.decay) !== null && _b !== void 0 ? _b : 1;
    if (!decrease || colorValue.status === "increasing") {
        colorValue.value += velocity;
        if (colorValue.value > max) {
            if (!colorValue.loops) {
                colorValue.loops = 0;
            }
            colorValue.loops++;
            if (decrease) {
                colorValue.status = "decreasing";
                colorValue.value -= colorValue.value % max;
            }
        }
    }
    else {
        colorValue.value -= velocity;
        if (colorValue.value < 0) {
            if (!colorValue.loops) {
                colorValue.loops = 0;
            }
            colorValue.loops++;
            colorValue.status = "increasing";
            colorValue.value += colorValue.value;
        }
    }
    if (colorValue.velocity && decay !== 1) {
        colorValue.velocity *= decay;
    }
    if (colorValue.value > max) {
        colorValue.value %= max;
    }
}
function updateColor(particle, delta) {
    var _a, _b, _c;
    const animationOptions = particle.options.color.animation;
    const h = (_a = particle.color) === null || _a === void 0 ? void 0 : _a.h, s = (_b = particle.color) === null || _b === void 0 ? void 0 : _b.s, l = (_c = particle.color) === null || _c === void 0 ? void 0 : _c.l;
    if (h) {
        updateColorValue(delta, h, animationOptions.h, 360, false);
    }
    if (s) {
        updateColorValue(delta, s, animationOptions.s, 100, true);
    }
    if (l) {
        updateColorValue(delta, l, animationOptions.l, 100, true);
    }
}
class ColorUpdater_ColorUpdater {
    constructor(container) {
        this.container = container;
    }
    init(particle) {
        const hslColor = Object(esm["U" /* rangeColorToHsl */])(particle.options.color, particle.id, particle.options.reduceDuplicates);
        if (hslColor) {
            particle.color = Object(esm["z" /* getHslAnimationFromHsl */])(hslColor, particle.options.color.animation, this.container.retina.reduceFactor);
        }
    }
    isEnabled(particle) {
        var _a, _b, _c;
        const animationOptions = particle.options.color.animation;
        return (!particle.destroyed &&
            !particle.spawning &&
            ((((_a = particle.color) === null || _a === void 0 ? void 0 : _a.h.value) !== undefined && animationOptions.h.enable) ||
                (((_b = particle.color) === null || _b === void 0 ? void 0 : _b.s.value) !== undefined && animationOptions.s.enable) ||
                (((_c = particle.color) === null || _c === void 0 ? void 0 : _c.l.value) !== undefined && animationOptions.l.enable)));
    }
    update(particle, delta) {
        updateColor(particle, delta);
    }
}

// CONCATENATED MODULE: ./node_modules/tsparticles-updater-color/esm/index.js

async function loadColorUpdater(engine) {
    await engine.addParticleUpdater("color", (container) => new ColorUpdater_ColorUpdater(container));
}

// CONCATENATED MODULE: ./node_modules/tsparticles-interaction-external-attract/esm/Options/Classes/Attract.js
class Attract {
    constructor() {
        this.distance = 200;
        this.duration = 0.4;
        this.easing = "ease-out-quad";
        this.factor = 1;
        this.maxSpeed = 50;
        this.speed = 1;
    }
    load(data) {
        if (!data) {
            return;
        }
        if (data.distance !== undefined) {
            this.distance = data.distance;
        }
        if (data.duration !== undefined) {
            this.duration = data.duration;
        }
        if (data.easing !== undefined) {
            this.easing = data.easing;
        }
        if (data.factor !== undefined) {
            this.factor = data.factor;
        }
        if (data.maxSpeed !== undefined) {
            this.maxSpeed = data.maxSpeed;
        }
        if (data.speed !== undefined) {
            this.speed = data.speed;
        }
    }
}

// CONCATENATED MODULE: ./node_modules/tsparticles-interaction-external-attract/esm/Attractor.js


class Attractor_Attractor extends esm["c" /* ExternalInteractorBase */] {
    constructor(engine, container) {
        super(container);
        this._engine = engine;
        if (!container.attract) {
            container.attract = { particles: [] };
        }
        this.handleClickMode = (mode) => {
            const options = this.container.actualOptions, attract = options.interactivity.modes.attract;
            if (!attract || mode !== "attract") {
                return;
            }
            if (!container.attract) {
                container.attract = { particles: [] };
            }
            container.attract.clicking = true;
            container.attract.count = 0;
            for (const particle of container.attract.particles) {
                if (!this.isEnabled(particle)) {
                    continue;
                }
                particle.velocity.setTo(particle.initialVelocity);
            }
            container.attract.particles = [];
            container.attract.finish = false;
            setTimeout(() => {
                if (!container.destroyed) {
                    if (!container.attract) {
                        container.attract = { particles: [] };
                    }
                    container.attract.clicking = false;
                }
            }, attract.duration * 1000);
        };
    }
    clear() {
    }
    init() {
        const container = this.container, attract = container.actualOptions.interactivity.modes.attract;
        if (!attract) {
            return;
        }
        container.retina.attractModeDistance = attract.distance * container.retina.pixelRatio;
    }
    async interact() {
        const container = this.container, options = container.actualOptions, mouseMoveStatus = container.interactivity.status === esm["S" /* mouseMoveEvent */], events = options.interactivity.events, hoverEnabled = events.onHover.enable, hoverMode = events.onHover.mode, clickEnabled = events.onClick.enable, clickMode = events.onClick.mode;
        if (mouseMoveStatus && hoverEnabled && Object(esm["K" /* isInArray */])("attract", hoverMode)) {
            this.hoverAttract();
        }
        else if (clickEnabled && Object(esm["K" /* isInArray */])("attract", clickMode)) {
            this.clickAttract();
        }
    }
    isEnabled(particle) {
        var _a;
        const container = this.container, options = container.actualOptions, mouse = container.interactivity.mouse, events = ((_a = particle === null || particle === void 0 ? void 0 : particle.interactivity) !== null && _a !== void 0 ? _a : options.interactivity).events;
        if ((!mouse.position || !events.onHover.enable) && (!mouse.clickPosition || !events.onClick.enable)) {
            return false;
        }
        const hoverMode = events.onHover.mode, clickMode = events.onClick.mode;
        return Object(esm["K" /* isInArray */])("attract", hoverMode) || Object(esm["K" /* isInArray */])("attract", clickMode);
    }
    loadModeOptions(options, ...sources) {
        if (!options.attract) {
            options.attract = new Attract();
        }
        for (const source of sources) {
            options.attract.load(source === null || source === void 0 ? void 0 : source.attract);
        }
    }
    reset() {
    }
    clickAttract() {
        const container = this.container;
        if (!container.attract) {
            container.attract = { particles: [] };
        }
        if (!container.attract.finish) {
            if (!container.attract.count) {
                container.attract.count = 0;
            }
            container.attract.count++;
            if (container.attract.count === container.particles.count) {
                container.attract.finish = true;
            }
        }
        if (container.attract.clicking) {
            const mousePos = container.interactivity.mouse.clickPosition, attractRadius = container.retina.attractModeDistance;
            if (!attractRadius || attractRadius < 0 || !mousePos) {
                return;
            }
            this.processAttract(mousePos, attractRadius, new esm["b" /* Circle */](mousePos.x, mousePos.y, attractRadius));
        }
        else if (container.attract.clicking === false) {
            container.attract.particles = [];
        }
        return;
    }
    hoverAttract() {
        const container = this.container, mousePos = container.interactivity.mouse.position, attractRadius = container.retina.attractModeDistance;
        if (!attractRadius || attractRadius < 0 || !mousePos) {
            return;
        }
        this.processAttract(mousePos, attractRadius, new esm["b" /* Circle */](mousePos.x, mousePos.y, attractRadius));
    }
    processAttract(position, attractRadius, area) {
        const container = this.container, attractOptions = container.actualOptions.interactivity.modes.attract;
        if (!attractOptions) {
            return;
        }
        const query = container.particles.quadTree.query(area, (p) => this.isEnabled(p));
        for (const particle of query) {
            const { dx, dy, distance } = Object(esm["x" /* getDistances */])(particle.position, position);
            const velocity = attractOptions.speed * attractOptions.factor;
            const attractFactor = Object(esm["o" /* clamp */])(Object(esm["y" /* getEasing */])(attractOptions.easing)(1 - distance / attractRadius) * velocity, 0, attractOptions.maxSpeed);
            const normVec = esm["h" /* Vector */].create(distance === 0 ? velocity : (dx / distance) * attractFactor, distance === 0 ? velocity : (dy / distance) * attractFactor);
            particle.position.subFrom(normVec);
        }
    }
}

// CONCATENATED MODULE: ./node_modules/tsparticles-interaction-external-attract/esm/Options/Interfaces/IAttract.js


// CONCATENATED MODULE: ./node_modules/tsparticles-interaction-external-attract/esm/index.js

async function loadExternalAttractInteraction(engine) {
    await engine.addInteractor("externalAttract", (container) => new Attractor_Attractor(engine, container));
}



// CONCATENATED MODULE: ./node_modules/tsparticles-interaction-external-bounce/esm/Options/Classes/Bounce.js
class Bounce {
    constructor() {
        this.distance = 200;
    }
    load(data) {
        if (!data) {
            return;
        }
        if (data.distance !== undefined) {
            this.distance = data.distance;
        }
    }
}

// CONCATENATED MODULE: ./node_modules/tsparticles-interaction-external-bounce/esm/Bouncer.js


class Bouncer_Bouncer extends esm["c" /* ExternalInteractorBase */] {
    constructor(container) {
        super(container);
    }
    clear() {
    }
    init() {
        const container = this.container, bounce = container.actualOptions.interactivity.modes.bounce;
        if (!bounce) {
            return;
        }
        container.retina.bounceModeDistance = bounce.distance * container.retina.pixelRatio;
    }
    async interact() {
        const container = this.container, options = container.actualOptions, events = options.interactivity.events, mouseMoveStatus = container.interactivity.status === esm["S" /* mouseMoveEvent */], hoverEnabled = events.onHover.enable, hoverMode = events.onHover.mode, divs = events.onDiv;
        if (mouseMoveStatus && hoverEnabled && Object(esm["K" /* isInArray */])("bounce", hoverMode)) {
            this.processMouseBounce();
        }
        else {
            Object(esm["s" /* divModeExecute */])("bounce", divs, (selector, div) => this.singleSelectorBounce(selector, div));
        }
    }
    isEnabled(particle) {
        var _a;
        const container = this.container, options = container.actualOptions, mouse = container.interactivity.mouse, events = ((_a = particle === null || particle === void 0 ? void 0 : particle.interactivity) !== null && _a !== void 0 ? _a : options.interactivity).events, divs = events.onDiv;
        return ((mouse.position && events.onHover.enable && Object(esm["K" /* isInArray */])("bounce", events.onHover.mode)) ||
            Object(esm["J" /* isDivModeEnabled */])("bounce", divs));
    }
    loadModeOptions(options, ...sources) {
        if (!options.bounce) {
            options.bounce = new Bounce();
        }
        for (const source of sources) {
            options.bounce.load(source === null || source === void 0 ? void 0 : source.bounce);
        }
    }
    reset() {
    }
    processBounce(position, radius, area) {
        const query = this.container.particles.quadTree.query(area, (p) => this.isEnabled(p));
        for (const particle of query) {
            if (area instanceof esm["b" /* Circle */]) {
                Object(esm["m" /* circleBounce */])(Object(esm["n" /* circleBounceDataFromParticle */])(particle), {
                    position,
                    radius,
                    mass: (radius ** 2 * Math.PI) / 2,
                    velocity: esm["h" /* Vector */].origin,
                    factor: esm["h" /* Vector */].origin,
                });
            }
            else if (area instanceof esm["f" /* Rectangle */]) {
                Object(esm["W" /* rectBounce */])(particle, Object(esm["l" /* calculateBounds */])(position, radius));
            }
        }
    }
    processMouseBounce() {
        const container = this.container, pxRatio = container.retina.pixelRatio, tolerance = 10 * pxRatio, mousePos = container.interactivity.mouse.position, radius = container.retina.bounceModeDistance;
        if (!radius || radius < 0 || !mousePos) {
            return;
        }
        this.processBounce(mousePos, radius, new esm["b" /* Circle */](mousePos.x, mousePos.y, radius + tolerance));
    }
    singleSelectorBounce(selector, div) {
        const container = this.container, query = document.querySelectorAll(selector);
        if (!query.length) {
            return;
        }
        query.forEach((item) => {
            const elem = item, pxRatio = container.retina.pixelRatio, pos = {
                x: (elem.offsetLeft + elem.offsetWidth / 2) * pxRatio,
                y: (elem.offsetTop + elem.offsetHeight / 2) * pxRatio,
            }, radius = (elem.offsetWidth / 2) * pxRatio, tolerance = 10 * pxRatio, area = div.type === "circle"
                ? new esm["b" /* Circle */](pos.x, pos.y, radius + tolerance)
                : new esm["f" /* Rectangle */](elem.offsetLeft * pxRatio - tolerance, elem.offsetTop * pxRatio - tolerance, elem.offsetWidth * pxRatio + tolerance * 2, elem.offsetHeight * pxRatio + tolerance * 2);
            this.processBounce(pos, radius, area);
        });
    }
}

// CONCATENATED MODULE: ./node_modules/tsparticles-interaction-external-bounce/esm/Options/Interfaces/IBounce.js


// CONCATENATED MODULE: ./node_modules/tsparticles-interaction-external-bounce/esm/index.js

async function loadExternalBounceInteraction(engine) {
    await engine.addInteractor("externalBounce", (container) => new Bouncer_Bouncer(container));
}



// CONCATENATED MODULE: ./node_modules/tsparticles-interaction-external-bubble/esm/Options/Classes/BubbleBase.js

class BubbleBase_BubbleBase {
    constructor() {
        this.distance = 200;
        this.duration = 0.4;
        this.mix = false;
    }
    load(data) {
        if (!data) {
            return;
        }
        if (data.distance !== undefined) {
            this.distance = data.distance;
        }
        if (data.duration !== undefined) {
            this.duration = data.duration;
        }
        if (data.mix !== undefined) {
            this.mix = data.mix;
        }
        if (data.opacity !== undefined) {
            this.opacity = data.opacity;
        }
        if (data.color !== undefined) {
            const sourceColor = this.color instanceof Array ? undefined : this.color;
            this.color = Object(esm["v" /* executeOnSingleOrMultiple */])(data.color, (color) => {
                return esm["d" /* OptionsColor */].create(sourceColor, color);
            });
        }
        if (data.size !== undefined) {
            this.size = data.size;
        }
    }
}

// CONCATENATED MODULE: ./node_modules/tsparticles-interaction-external-bubble/esm/Options/Classes/BubbleDiv.js


class BubbleDiv_BubbleDiv extends BubbleBase_BubbleBase {
    constructor() {
        super();
        this.selectors = [];
    }
    get ids() {
        return Object(esm["v" /* executeOnSingleOrMultiple */])(this.selectors, (t) => t.replace("#", ""));
    }
    set ids(value) {
        this.selectors = Object(esm["v" /* executeOnSingleOrMultiple */])(value, (t) => `#${t}`);
    }
    load(data) {
        super.load(data);
        if (!data) {
            return;
        }
        if (data.ids !== undefined) {
            this.ids = data.ids;
        }
        if (data.selectors !== undefined) {
            this.selectors = data.selectors;
        }
    }
}

// CONCATENATED MODULE: ./node_modules/tsparticles-interaction-external-bubble/esm/Options/Classes/Bubble.js



class Bubble_Bubble extends BubbleBase_BubbleBase {
    load(data) {
        super.load(data);
        if (!data) {
            return;
        }
        this.divs = Object(esm["v" /* executeOnSingleOrMultiple */])(data.divs, (div) => {
            const tmp = new BubbleDiv_BubbleDiv();
            tmp.load(div);
            return tmp;
        });
    }
}

// CONCATENATED MODULE: ./node_modules/tsparticles-interaction-external-bubble/esm/Bubbler.js


function calculateBubbleValue(particleValue, modeValue, optionsValue, ratio) {
    if (modeValue >= optionsValue) {
        const value = particleValue + (modeValue - optionsValue) * ratio;
        return Object(esm["o" /* clamp */])(value, particleValue, modeValue);
    }
    else if (modeValue < optionsValue) {
        const value = particleValue - (optionsValue - modeValue) * ratio;
        return Object(esm["o" /* clamp */])(value, modeValue, particleValue);
    }
}
class Bubbler_Bubbler extends esm["c" /* ExternalInteractorBase */] {
    constructor(container) {
        super(container);
        if (!container.bubble) {
            container.bubble = {};
        }
        this.handleClickMode = (mode) => {
            if (mode !== "bubble") {
                return;
            }
            if (!container.bubble) {
                container.bubble = {};
            }
            container.bubble.clicking = true;
        };
    }
    clear(particle, delta, force) {
        if (particle.bubble.inRange && !force) {
            return;
        }
        delete particle.bubble.div;
        delete particle.bubble.opacity;
        delete particle.bubble.radius;
        delete particle.bubble.color;
    }
    init() {
        const container = this.container, bubble = container.actualOptions.interactivity.modes.bubble;
        if (!bubble) {
            return;
        }
        container.retina.bubbleModeDistance = bubble.distance * container.retina.pixelRatio;
        if (bubble.size !== undefined) {
            container.retina.bubbleModeSize = bubble.size * container.retina.pixelRatio;
        }
    }
    async interact(delta) {
        const options = this.container.actualOptions, events = options.interactivity.events, onHover = events.onHover, onClick = events.onClick, hoverEnabled = onHover.enable, hoverMode = onHover.mode, clickEnabled = onClick.enable, clickMode = onClick.mode, divs = events.onDiv;
        if (hoverEnabled && Object(esm["K" /* isInArray */])("bubble", hoverMode)) {
            this.hoverBubble(delta);
        }
        else if (clickEnabled && Object(esm["K" /* isInArray */])("bubble", clickMode)) {
            this.clickBubble(delta);
        }
        else {
            Object(esm["s" /* divModeExecute */])("bubble", divs, (selector, div) => this.singleSelectorHover(delta, selector, div));
        }
    }
    isEnabled(particle) {
        var _a;
        const container = this.container, options = container.actualOptions, mouse = container.interactivity.mouse, events = ((_a = particle === null || particle === void 0 ? void 0 : particle.interactivity) !== null && _a !== void 0 ? _a : options.interactivity).events, divs = events.onDiv, divBubble = Object(esm["J" /* isDivModeEnabled */])("bubble", divs);
        if (!(divBubble || (events.onHover.enable && mouse.position) || (events.onClick.enable && mouse.clickPosition))) {
            return false;
        }
        const hoverMode = events.onHover.mode;
        const clickMode = events.onClick.mode;
        return Object(esm["K" /* isInArray */])("bubble", hoverMode) || Object(esm["K" /* isInArray */])("bubble", clickMode) || divBubble;
    }
    loadModeOptions(options, ...sources) {
        if (!options.bubble) {
            options.bubble = new Bubble_Bubble();
        }
        for (const source of sources) {
            options.bubble.load(source === null || source === void 0 ? void 0 : source.bubble);
        }
    }
    reset(particle) {
        particle.bubble.inRange = false;
    }
    clickBubble(delta) {
        var _a, _b;
        const container = this.container, options = container.actualOptions, mouseClickPos = container.interactivity.mouse.clickPosition, bubble = options.interactivity.modes.bubble;
        if (!bubble || !mouseClickPos) {
            return;
        }
        if (!container.bubble) {
            container.bubble = {};
        }
        const distance = container.retina.bubbleModeDistance;
        if (!distance || distance < 0) {
            return;
        }
        const query = container.particles.quadTree.queryCircle(mouseClickPos, distance, (p) => this.isEnabled(p));
        for (const particle of query) {
            if (!container.bubble.clicking) {
                continue;
            }
            particle.bubble.inRange = !container.bubble.durationEnd;
            const pos = particle.getPosition(), distMouse = Object(esm["w" /* getDistance */])(pos, mouseClickPos), timeSpent = (new Date().getTime() - (container.interactivity.mouse.clickTime || 0)) / 1000;
            if (timeSpent > bubble.duration) {
                container.bubble.durationEnd = true;
            }
            if (timeSpent > bubble.duration * 2) {
                container.bubble.clicking = false;
                container.bubble.durationEnd = false;
            }
            const sizeData = {
                bubbleObj: {
                    optValue: container.retina.bubbleModeSize,
                    value: particle.bubble.radius,
                },
                particlesObj: {
                    optValue: Object(esm["D" /* getRangeMax */])(particle.options.size.value) * container.retina.pixelRatio,
                    value: particle.size.value,
                },
                type: "size",
            };
            this.process(particle, distMouse, timeSpent, sizeData);
            const opacityData = {
                bubbleObj: {
                    optValue: bubble.opacity,
                    value: particle.bubble.opacity,
                },
                particlesObj: {
                    optValue: Object(esm["D" /* getRangeMax */])(particle.options.opacity.value),
                    value: (_b = (_a = particle.opacity) === null || _a === void 0 ? void 0 : _a.value) !== null && _b !== void 0 ? _b : 1,
                },
                type: "opacity",
            };
            this.process(particle, distMouse, timeSpent, opacityData);
            if (!container.bubble.durationEnd) {
                if (distMouse <= distance) {
                    this.hoverBubbleColor(particle, distMouse);
                }
                else {
                    delete particle.bubble.color;
                }
            }
            else {
                delete particle.bubble.color;
            }
        }
    }
    hoverBubble(delta) {
        const container = this.container, mousePos = container.interactivity.mouse.position, distance = container.retina.bubbleModeDistance;
        if (!distance || distance < 0 || mousePos === undefined) {
            return;
        }
        const query = container.particles.quadTree.queryCircle(mousePos, distance, (p) => this.isEnabled(p));
        for (const particle of query) {
            particle.bubble.inRange = true;
            const pos = particle.getPosition(), pointDistance = Object(esm["w" /* getDistance */])(pos, mousePos), ratio = 1 - pointDistance / distance;
            if (pointDistance <= distance) {
                if (ratio >= 0 && container.interactivity.status === esm["S" /* mouseMoveEvent */]) {
                    this.hoverBubbleSize(particle, ratio);
                    this.hoverBubbleOpacity(particle, ratio);
                    this.hoverBubbleColor(particle, ratio);
                }
            }
            else {
                this.reset(particle);
            }
            if (container.interactivity.status === esm["R" /* mouseLeaveEvent */]) {
                this.reset(particle);
            }
        }
    }
    hoverBubbleColor(particle, ratio, divBubble) {
        const options = this.container.actualOptions;
        const bubbleOptions = divBubble !== null && divBubble !== void 0 ? divBubble : options.interactivity.modes.bubble;
        if (!bubbleOptions) {
            return;
        }
        if (!particle.bubble.finalColor) {
            const modeColor = bubbleOptions.color;
            if (!modeColor) {
                return;
            }
            const bubbleColor = Object(esm["O" /* itemFromSingleOrMultiple */])(modeColor);
            particle.bubble.finalColor = Object(esm["U" /* rangeColorToHsl */])(bubbleColor);
        }
        if (!particle.bubble.finalColor) {
            return;
        }
        if (bubbleOptions.mix) {
            particle.bubble.color = undefined;
            const pColor = particle.getFillColor();
            particle.bubble.color = pColor
                ? Object(esm["X" /* rgbToHsl */])(Object(esm["p" /* colorMix */])(pColor, particle.bubble.finalColor, 1 - ratio, ratio))
                : particle.bubble.finalColor;
        }
        else {
            particle.bubble.color = particle.bubble.finalColor;
        }
    }
    hoverBubbleOpacity(particle, ratio, divBubble) {
        var _a, _b, _c, _d;
        const container = this.container, options = container.actualOptions, modeOpacity = (_a = divBubble === null || divBubble === void 0 ? void 0 : divBubble.opacity) !== null && _a !== void 0 ? _a : (_b = options.interactivity.modes.bubble) === null || _b === void 0 ? void 0 : _b.opacity;
        if (!modeOpacity) {
            return;
        }
        const optOpacity = particle.options.opacity.value;
        const pOpacity = (_d = (_c = particle.opacity) === null || _c === void 0 ? void 0 : _c.value) !== null && _d !== void 0 ? _d : 1;
        const opacity = calculateBubbleValue(pOpacity, modeOpacity, Object(esm["D" /* getRangeMax */])(optOpacity), ratio);
        if (opacity !== undefined) {
            particle.bubble.opacity = opacity;
        }
    }
    hoverBubbleSize(particle, ratio, divBubble) {
        const container = this.container, modeSize = (divBubble === null || divBubble === void 0 ? void 0 : divBubble.size) ? divBubble.size * container.retina.pixelRatio : container.retina.bubbleModeSize;
        if (modeSize === undefined) {
            return;
        }
        const optSize = Object(esm["D" /* getRangeMax */])(particle.options.size.value) * container.retina.pixelRatio;
        const pSize = particle.size.value;
        const size = calculateBubbleValue(pSize, modeSize, optSize, ratio);
        if (size !== undefined) {
            particle.bubble.radius = size;
        }
    }
    process(particle, distMouse, timeSpent, data) {
        const container = this.container, bubbleParam = data.bubbleObj.optValue, options = container.actualOptions, bubble = options.interactivity.modes.bubble;
        if (!bubble || bubbleParam === undefined) {
            return;
        }
        const bubbleDuration = bubble.duration, bubbleDistance = container.retina.bubbleModeDistance, particlesParam = data.particlesObj.optValue, pObjBubble = data.bubbleObj.value, pObj = data.particlesObj.value || 0, type = data.type;
        if (!bubbleDistance || bubbleDistance < 0 || bubbleParam === particlesParam) {
            return;
        }
        if (!container.bubble) {
            container.bubble = {};
        }
        if (!container.bubble.durationEnd) {
            if (distMouse <= bubbleDistance) {
                const obj = pObjBubble !== null && pObjBubble !== void 0 ? pObjBubble : pObj;
                if (obj !== bubbleParam) {
                    const value = pObj - (timeSpent * (pObj - bubbleParam)) / bubbleDuration;
                    if (type === "size") {
                        particle.bubble.radius = value;
                    }
                    if (type === "opacity") {
                        particle.bubble.opacity = value;
                    }
                }
            }
            else {
                if (type === "size") {
                    delete particle.bubble.radius;
                }
                if (type === "opacity") {
                    delete particle.bubble.opacity;
                }
            }
        }
        else if (pObjBubble) {
            if (type === "size") {
                delete particle.bubble.radius;
            }
            if (type === "opacity") {
                delete particle.bubble.opacity;
            }
        }
    }
    singleSelectorHover(delta, selector, div) {
        const container = this.container, selectors = document.querySelectorAll(selector), bubble = container.actualOptions.interactivity.modes.bubble;
        if (!bubble || !selectors.length) {
            return;
        }
        selectors.forEach((item) => {
            const elem = item, pxRatio = container.retina.pixelRatio, pos = {
                x: (elem.offsetLeft + elem.offsetWidth / 2) * pxRatio,
                y: (elem.offsetTop + elem.offsetHeight / 2) * pxRatio,
            }, repulseRadius = (elem.offsetWidth / 2) * pxRatio, area = div.type === "circle"
                ? new esm["b" /* Circle */](pos.x, pos.y, repulseRadius)
                : new esm["f" /* Rectangle */](elem.offsetLeft * pxRatio, elem.offsetTop * pxRatio, elem.offsetWidth * pxRatio, elem.offsetHeight * pxRatio), query = container.particles.quadTree.query(area, (p) => this.isEnabled(p));
            for (const particle of query) {
                if (!area.contains(particle.getPosition())) {
                    continue;
                }
                particle.bubble.inRange = true;
                const divs = bubble.divs;
                const divBubble = Object(esm["r" /* divMode */])(divs, elem);
                if (!particle.bubble.div || particle.bubble.div !== elem) {
                    this.clear(particle, delta, true);
                    particle.bubble.div = elem;
                }
                this.hoverBubbleSize(particle, 1, divBubble);
                this.hoverBubbleOpacity(particle, 1, divBubble);
                this.hoverBubbleColor(particle, 1, divBubble);
            }
        });
    }
}

// CONCATENATED MODULE: ./node_modules/tsparticles-interaction-external-bubble/esm/Options/Interfaces/IBubbleBase.js


// CONCATENATED MODULE: ./node_modules/tsparticles-interaction-external-bubble/esm/Options/Interfaces/IBubbleDiv.js


// CONCATENATED MODULE: ./node_modules/tsparticles-interaction-external-bubble/esm/Options/Interfaces/IBubble.js


// CONCATENATED MODULE: ./node_modules/tsparticles-interaction-external-bubble/esm/index.js

async function loadExternalBubbleInteraction(engine) {
    await engine.addInteractor("externalBubble", (container) => new Bubbler_Bubbler(container));
}







// CONCATENATED MODULE: ./node_modules/tsparticles-interaction-external-connect/esm/Options/Classes/ConnectLinks.js
class ConnectLinks {
    constructor() {
        this.opacity = 0.5;
    }
    load(data) {
        if (!data) {
            return;
        }
        if (data.opacity !== undefined) {
            this.opacity = data.opacity;
        }
    }
}

// CONCATENATED MODULE: ./node_modules/tsparticles-interaction-external-connect/esm/Options/Classes/Connect.js

class Connect_Connect {
    constructor() {
        this.distance = 80;
        this.links = new ConnectLinks();
        this.radius = 60;
    }
    get lineLinked() {
        return this.links;
    }
    set lineLinked(value) {
        this.links = value;
    }
    get line_linked() {
        return this.links;
    }
    set line_linked(value) {
        this.links = value;
    }
    load(data) {
        var _a, _b;
        if (!data) {
            return;
        }
        if (data.distance !== undefined) {
            this.distance = data.distance;
        }
        this.links.load((_b = (_a = data.links) !== null && _a !== void 0 ? _a : data.lineLinked) !== null && _b !== void 0 ? _b : data.line_linked);
        if (data.radius !== undefined) {
            this.radius = data.radius;
        }
    }
}

// CONCATENATED MODULE: ./node_modules/tsparticles-interaction-external-connect/esm/Connector.js


function gradient(context, p1, p2, opacity) {
    const gradStop = Math.floor(p2.getRadius() / p1.getRadius()), color1 = p1.getFillColor(), color2 = p2.getFillColor();
    if (!color1 || !color2) {
        return;
    }
    const sourcePos = p1.getPosition(), destPos = p2.getPosition(), midRgb = Object(esm["p" /* colorMix */])(color1, color2, p1.getRadius(), p2.getRadius()), grad = context.createLinearGradient(sourcePos.x, sourcePos.y, destPos.x, destPos.y);
    grad.addColorStop(0, Object(esm["G" /* getStyleFromHsl */])(color1, opacity));
    grad.addColorStop(gradStop > 1 ? 1 : gradStop, Object(esm["H" /* getStyleFromRgb */])(midRgb, opacity));
    grad.addColorStop(1, Object(esm["G" /* getStyleFromHsl */])(color2, opacity));
    return grad;
}
function drawConnectLine(context, width, lineStyle, begin, end) {
    Object(esm["t" /* drawLine */])(context, begin, end);
    context.lineWidth = width;
    context.strokeStyle = lineStyle;
    context.stroke();
}
function Connector_lineStyle(container, ctx, p1, p2) {
    const options = container.actualOptions, connectOptions = options.interactivity.modes.connect;
    if (!connectOptions) {
        return;
    }
    return gradient(ctx, p1, p2, connectOptions.links.opacity);
}
function drawConnection(container, p1, p2) {
    container.canvas.draw((ctx) => {
        var _a;
        const ls = Connector_lineStyle(container, ctx, p1, p2);
        if (!ls) {
            return;
        }
        const pos1 = p1.getPosition(), pos2 = p2.getPosition();
        drawConnectLine(ctx, (_a = p1.retina.linksWidth) !== null && _a !== void 0 ? _a : 0, ls, pos1, pos2);
    });
}
class Connector_Connector extends esm["c" /* ExternalInteractorBase */] {
    constructor(container) {
        super(container);
    }
    clear() {
    }
    init() {
        const container = this.container, connect = container.actualOptions.interactivity.modes.connect;
        if (!connect) {
            return;
        }
        container.retina.connectModeDistance = connect.distance * container.retina.pixelRatio;
        container.retina.connectModeRadius = connect.radius * container.retina.pixelRatio;
    }
    async interact() {
        const container = this.container, options = container.actualOptions;
        if (options.interactivity.events.onHover.enable && container.interactivity.status === "pointermove") {
            const mousePos = container.interactivity.mouse.position;
            if (!container.retina.connectModeDistance ||
                container.retina.connectModeDistance < 0 ||
                !container.retina.connectModeRadius ||
                container.retina.connectModeRadius < 0 ||
                !mousePos) {
                return;
            }
            const distance = Math.abs(container.retina.connectModeRadius), query = container.particles.quadTree.queryCircle(mousePos, distance, (p) => this.isEnabled(p));
            let i = 0;
            for (const p1 of query) {
                const pos1 = p1.getPosition();
                for (const p2 of query.slice(i + 1)) {
                    const pos2 = p2.getPosition(), distMax = Math.abs(container.retina.connectModeDistance), xDiff = Math.abs(pos1.x - pos2.x), yDiff = Math.abs(pos1.y - pos2.y);
                    if (xDiff < distMax && yDiff < distMax) {
                        drawConnection(container, p1, p2);
                    }
                }
                ++i;
            }
        }
    }
    isEnabled(particle) {
        var _a;
        const container = this.container, mouse = container.interactivity.mouse, events = ((_a = particle === null || particle === void 0 ? void 0 : particle.interactivity) !== null && _a !== void 0 ? _a : container.actualOptions.interactivity).events;
        if (!(events.onHover.enable && mouse.position)) {
            return false;
        }
        return Object(esm["K" /* isInArray */])("connect", events.onHover.mode);
    }
    loadModeOptions(options, ...sources) {
        if (!options.connect) {
            options.connect = new Connect_Connect();
        }
        for (const source of sources) {
            options.connect.load(source === null || source === void 0 ? void 0 : source.connect);
        }
    }
    reset() {
    }
}

// CONCATENATED MODULE: ./node_modules/tsparticles-interaction-external-connect/esm/Options/Interfaces/IConnect.js


// CONCATENATED MODULE: ./node_modules/tsparticles-interaction-external-connect/esm/Options/Interfaces/IConnectLinks.js


// CONCATENATED MODULE: ./node_modules/tsparticles-interaction-external-connect/esm/index.js

async function loadExternalConnectInteraction(engine) {
    await engine.addInteractor("externalConnect", (container) => new Connector_Connector(container));
}





// CONCATENATED MODULE: ./node_modules/tsparticles-interaction-external-grab/esm/Options/Classes/GrabLinks.js

class GrabLinks_GrabLinks {
    constructor() {
        this.blink = false;
        this.consent = false;
        this.opacity = 1;
    }
    load(data) {
        if (!data) {
            return;
        }
        if (data.blink !== undefined) {
            this.blink = data.blink;
        }
        if (data.color !== undefined) {
            this.color = esm["d" /* OptionsColor */].create(this.color, data.color);
        }
        if (data.consent !== undefined) {
            this.consent = data.consent;
        }
        if (data.opacity !== undefined) {
            this.opacity = data.opacity;
        }
    }
}

// CONCATENATED MODULE: ./node_modules/tsparticles-interaction-external-grab/esm/Options/Classes/Grab.js

class Grab_Grab {
    constructor() {
        this.distance = 100;
        this.links = new GrabLinks_GrabLinks();
    }
    get lineLinked() {
        return this.links;
    }
    set lineLinked(value) {
        this.links = value;
    }
    get line_linked() {
        return this.links;
    }
    set line_linked(value) {
        this.links = value;
    }
    load(data) {
        var _a, _b;
        if (!data) {
            return;
        }
        if (data.distance !== undefined) {
            this.distance = data.distance;
        }
        this.links.load((_b = (_a = data.links) !== null && _a !== void 0 ? _a : data.lineLinked) !== null && _b !== void 0 ? _b : data.line_linked);
    }
}

// CONCATENATED MODULE: ./node_modules/tsparticles-interaction-external-grab/esm/Grabber.js


function drawGrabLine(context, width, begin, end, colorLine, opacity) {
    Object(esm["t" /* drawLine */])(context, begin, end);
    context.strokeStyle = Object(esm["H" /* getStyleFromRgb */])(colorLine, opacity);
    context.lineWidth = width;
    context.stroke();
}
function drawGrab(container, particle, lineColor, opacity, mousePos) {
    container.canvas.draw((ctx) => {
        var _a;
        const beginPos = particle.getPosition();
        drawGrabLine(ctx, (_a = particle.retina.linksWidth) !== null && _a !== void 0 ? _a : 0, beginPos, mousePos, lineColor, opacity);
    });
}
class Grabber_Grabber extends esm["c" /* ExternalInteractorBase */] {
    constructor(container) {
        super(container);
    }
    clear() {
    }
    init() {
        const container = this.container, grab = container.actualOptions.interactivity.modes.grab;
        if (!grab) {
            return;
        }
        container.retina.grabModeDistance = grab.distance * container.retina.pixelRatio;
    }
    async interact() {
        var _a, _b;
        const container = this.container, options = container.actualOptions, interactivity = options.interactivity;
        if (!interactivity.modes.grab ||
            !interactivity.events.onHover.enable ||
            container.interactivity.status !== esm["S" /* mouseMoveEvent */]) {
            return;
        }
        const mousePos = container.interactivity.mouse.position;
        if (!mousePos) {
            return;
        }
        const distance = container.retina.grabModeDistance;
        if (!distance || distance < 0) {
            return;
        }
        const query = container.particles.quadTree.queryCircle(mousePos, distance, (p) => this.isEnabled(p));
        for (const particle of query) {
            const pos = particle.getPosition(), pointDistance = Object(esm["w" /* getDistance */])(pos, mousePos);
            if (pointDistance > distance) {
                continue;
            }
            const grabLineOptions = interactivity.modes.grab.links, lineOpacity = grabLineOptions.opacity, opacityLine = lineOpacity - (pointDistance * lineOpacity) / distance;
            if (opacityLine <= 0) {
                continue;
            }
            const optColor = (_a = grabLineOptions.color) !== null && _a !== void 0 ? _a : (_b = particle.options.links) === null || _b === void 0 ? void 0 : _b.color;
            if (!container.particles.grabLineColor && optColor) {
                const linksOptions = interactivity.modes.grab.links;
                container.particles.grabLineColor = Object(esm["B" /* getLinkRandomColor */])(optColor, linksOptions.blink, linksOptions.consent);
            }
            const colorLine = Object(esm["A" /* getLinkColor */])(particle, undefined, container.particles.grabLineColor);
            if (!colorLine) {
                return;
            }
            drawGrab(container, particle, colorLine, opacityLine, mousePos);
        }
    }
    isEnabled(particle) {
        var _a;
        const container = this.container, mouse = container.interactivity.mouse, events = ((_a = particle === null || particle === void 0 ? void 0 : particle.interactivity) !== null && _a !== void 0 ? _a : container.actualOptions.interactivity).events;
        return events.onHover.enable && !!mouse.position && Object(esm["K" /* isInArray */])("grab", events.onHover.mode);
    }
    loadModeOptions(options, ...sources) {
        if (!options.grab) {
            options.grab = new Grab_Grab();
        }
        for (const source of sources) {
            options.grab.load(source === null || source === void 0 ? void 0 : source.grab);
        }
    }
    reset() {
    }
}

// CONCATENATED MODULE: ./node_modules/tsparticles-interaction-external-grab/esm/Options/Interfaces/IGrab.js


// CONCATENATED MODULE: ./node_modules/tsparticles-interaction-external-grab/esm/Options/Interfaces/IGrabLinks.js


// CONCATENATED MODULE: ./node_modules/tsparticles-interaction-external-grab/esm/index.js

async function loadExternalGrabInteraction(engine) {
    await engine.addInteractor("externalGrab", (container) => new Grabber_Grabber(container));
}





// CONCATENATED MODULE: ./node_modules/tsparticles-interaction-external-pause/esm/Pauser.js

class Pauser_Pauser extends esm["c" /* ExternalInteractorBase */] {
    constructor(container) {
        super(container);
        this.handleClickMode = (mode) => {
            if (mode !== "pause") {
                return;
            }
            const container = this.container;
            if (container.getAnimationStatus()) {
                container.pause();
            }
            else {
                container.play();
            }
        };
    }
    clear() {
    }
    init() {
    }
    async interact() {
    }
    isEnabled() {
        return true;
    }
    reset() {
    }
}

// CONCATENATED MODULE: ./node_modules/tsparticles-interaction-external-pause/esm/index.js

function loadExternalPauseInteraction(engine) {
    engine.addInteractor("externalPause", (container) => new Pauser_Pauser(container));
}

// CONCATENATED MODULE: ./node_modules/tsparticles-interaction-external-push/esm/Options/Classes/Push.js
class Push {
    constructor() {
        this.default = true;
        this.groups = [];
        this.quantity = 4;
    }
    get particles_nb() {
        return this.quantity;
    }
    set particles_nb(value) {
        this.quantity = value;
    }
    load(data) {
        var _a;
        if (!data) {
            return;
        }
        if (data.default !== undefined) {
            this.default = data.default;
        }
        if (data.groups !== undefined) {
            this.groups = data.groups.map((t) => t);
        }
        if (!this.groups.length) {
            this.default = true;
        }
        const quantity = (_a = data.quantity) !== null && _a !== void 0 ? _a : data.particles_nb;
        if (quantity !== undefined) {
            this.quantity = quantity;
        }
    }
}

// CONCATENATED MODULE: ./node_modules/tsparticles-interaction-external-push/esm/Pusher.js



class Pusher_Pusher extends esm["c" /* ExternalInteractorBase */] {
    constructor(container) {
        super(container);
        this.handleClickMode = (mode) => {
            if (mode !== "push") {
                return;
            }
            const container = this.container, options = container.actualOptions, pushOptions = options.interactivity.modes.push;
            if (!pushOptions) {
                return;
            }
            const pushNb = pushOptions.quantity;
            if (pushNb <= 0) {
                return;
            }
            const group = Object(esm["N" /* itemFromArray */])([undefined, ...pushOptions.groups]), groupOptions = group !== undefined ? container.actualOptions.particles.groups[group] : undefined;
            container.particles.push(pushNb, container.interactivity.mouse, groupOptions, group);
        };
    }
    clear() {
    }
    init() {
    }
    async interact() {
    }
    isEnabled() {
        return true;
    }
    loadModeOptions(options, ...sources) {
        if (!options.push) {
            options.push = new Push();
        }
        for (const source of sources) {
            options.push.load(source === null || source === void 0 ? void 0 : source.push);
        }
    }
    reset() {
    }
}

// CONCATENATED MODULE: ./node_modules/tsparticles-interaction-external-push/esm/Options/Interfaces/IPush.js


// CONCATENATED MODULE: ./node_modules/tsparticles-interaction-external-push/esm/index.js

async function loadExternalPushInteraction(engine) {
    await engine.addInteractor("externalPush", (container) => new Pusher_Pusher(container));
}



// CONCATENATED MODULE: ./node_modules/tsparticles-interaction-external-remove/esm/Options/Classes/Remove.js
class Remove {
    constructor() {
        this.quantity = 2;
    }
    get particles_nb() {
        return this.quantity;
    }
    set particles_nb(value) {
        this.quantity = value;
    }
    load(data) {
        var _a;
        if (!data) {
            return;
        }
        const quantity = (_a = data.quantity) !== null && _a !== void 0 ? _a : data.particles_nb;
        if (quantity !== undefined) {
            this.quantity = quantity;
        }
    }
}

// CONCATENATED MODULE: ./node_modules/tsparticles-interaction-external-remove/esm/Remover.js


class Remover_Remover extends esm["c" /* ExternalInteractorBase */] {
    constructor(container) {
        super(container);
        this.handleClickMode = (mode) => {
            const container = this.container, options = container.actualOptions;
            if (!options.interactivity.modes.remove || mode !== "remove") {
                return;
            }
            const removeNb = options.interactivity.modes.remove.quantity;
            container.particles.removeQuantity(removeNb);
        };
    }
    clear() {
    }
    init() {
    }
    async interact() {
    }
    isEnabled() {
        return true;
    }
    loadModeOptions(options, ...sources) {
        if (!options.remove) {
            options.remove = new Remove();
        }
        for (const source of sources) {
            options.remove.load(source === null || source === void 0 ? void 0 : source.remove);
        }
    }
    reset() {
    }
}

// CONCATENATED MODULE: ./node_modules/tsparticles-interaction-external-remove/esm/Options/Interfaces/IRemove.js


// CONCATENATED MODULE: ./node_modules/tsparticles-interaction-external-remove/esm/index.js

function loadExternalRemoveInteraction(engine) {
    engine.addInteractor("externalRemove", (container) => new Remover_Remover(container));
}



// CONCATENATED MODULE: ./node_modules/tsparticles-interaction-external-repulse/esm/Options/Classes/RepulseBase.js
class RepulseBase {
    constructor() {
        this.distance = 200;
        this.duration = 0.4;
        this.factor = 100;
        this.speed = 1;
        this.maxSpeed = 50;
        this.easing = "ease-out-quad";
    }
    load(data) {
        if (!data) {
            return;
        }
        if (data.distance !== undefined) {
            this.distance = data.distance;
        }
        if (data.duration !== undefined) {
            this.duration = data.duration;
        }
        if (data.easing !== undefined) {
            this.easing = data.easing;
        }
        if (data.factor !== undefined) {
            this.factor = data.factor;
        }
        if (data.speed !== undefined) {
            this.speed = data.speed;
        }
        if (data.maxSpeed !== undefined) {
            this.maxSpeed = data.maxSpeed;
        }
    }
}

// CONCATENATED MODULE: ./node_modules/tsparticles-interaction-external-repulse/esm/Options/Classes/RepulseDiv.js


class RepulseDiv_RepulseDiv extends RepulseBase {
    constructor() {
        super();
        this.selectors = [];
    }
    get ids() {
        return Object(esm["v" /* executeOnSingleOrMultiple */])(this.selectors, (t) => t.replace("#", ""));
    }
    set ids(value) {
        this.selectors = Object(esm["v" /* executeOnSingleOrMultiple */])(value, (t) => `#${t}`);
    }
    load(data) {
        super.load(data);
        if (!data) {
            return;
        }
        if (data.ids !== undefined) {
            this.ids = data.ids;
        }
        if (data.selectors !== undefined) {
            this.selectors = data.selectors;
        }
    }
}

// CONCATENATED MODULE: ./node_modules/tsparticles-interaction-external-repulse/esm/Options/Classes/Repulse.js



class Repulse_Repulse extends RepulseBase {
    load(data) {
        super.load(data);
        if (!data) {
            return;
        }
        this.divs = Object(esm["v" /* executeOnSingleOrMultiple */])(data.divs, (div) => {
            const tmp = new RepulseDiv_RepulseDiv();
            tmp.load(div);
            return tmp;
        });
    }
}

// CONCATENATED MODULE: ./node_modules/tsparticles-interaction-external-repulse/esm/Repulser.js


class Repulser_Repulser extends esm["c" /* ExternalInteractorBase */] {
    constructor(engine, container) {
        super(container);
        this._engine = engine;
        if (!container.repulse) {
            container.repulse = { particles: [] };
        }
        this.handleClickMode = (mode) => {
            const options = this.container.actualOptions, repulse = options.interactivity.modes.repulse;
            if (!repulse || mode !== "repulse") {
                return;
            }
            if (!container.repulse) {
                container.repulse = { particles: [] };
            }
            container.repulse.clicking = true;
            container.repulse.count = 0;
            for (const particle of container.repulse.particles) {
                if (!this.isEnabled(particle)) {
                    continue;
                }
                particle.velocity.setTo(particle.initialVelocity);
            }
            container.repulse.particles = [];
            container.repulse.finish = false;
            setTimeout(() => {
                if (!container.destroyed) {
                    if (!container.repulse) {
                        container.repulse = { particles: [] };
                    }
                    container.repulse.clicking = false;
                }
            }, repulse.duration * 1000);
        };
    }
    clear() {
    }
    init() {
        const container = this.container, repulse = container.actualOptions.interactivity.modes.repulse;
        if (!repulse) {
            return;
        }
        container.retina.repulseModeDistance = repulse.distance * container.retina.pixelRatio;
    }
    async interact() {
        const container = this.container, options = container.actualOptions, mouseMoveStatus = container.interactivity.status === esm["S" /* mouseMoveEvent */], events = options.interactivity.events, hoverEnabled = events.onHover.enable, hoverMode = events.onHover.mode, clickEnabled = events.onClick.enable, clickMode = events.onClick.mode, divs = events.onDiv;
        if (mouseMoveStatus && hoverEnabled && Object(esm["K" /* isInArray */])("repulse", hoverMode)) {
            this.hoverRepulse();
        }
        else if (clickEnabled && Object(esm["K" /* isInArray */])("repulse", clickMode)) {
            this.clickRepulse();
        }
        else {
            Object(esm["s" /* divModeExecute */])("repulse", divs, (selector, div) => this.singleSelectorRepulse(selector, div));
        }
    }
    isEnabled(particle) {
        var _a;
        const container = this.container, options = container.actualOptions, mouse = container.interactivity.mouse, events = ((_a = particle === null || particle === void 0 ? void 0 : particle.interactivity) !== null && _a !== void 0 ? _a : options.interactivity).events, divs = events.onDiv, divRepulse = Object(esm["J" /* isDivModeEnabled */])("repulse", divs);
        if (!(divRepulse || (events.onHover.enable && mouse.position) || (events.onClick.enable && mouse.clickPosition))) {
            return false;
        }
        const hoverMode = events.onHover.mode, clickMode = events.onClick.mode;
        return Object(esm["K" /* isInArray */])("repulse", hoverMode) || Object(esm["K" /* isInArray */])("repulse", clickMode) || divRepulse;
    }
    loadModeOptions(options, ...sources) {
        if (!options.repulse) {
            options.repulse = new Repulse_Repulse();
        }
        for (const source of sources) {
            options.repulse.load(source === null || source === void 0 ? void 0 : source.repulse);
        }
    }
    reset() {
    }
    clickRepulse() {
        const container = this.container, repulse = container.actualOptions.interactivity.modes.repulse;
        if (!repulse) {
            return;
        }
        if (!container.repulse) {
            container.repulse = { particles: [] };
        }
        if (!container.repulse.finish) {
            if (!container.repulse.count) {
                container.repulse.count = 0;
            }
            container.repulse.count++;
            if (container.repulse.count === container.particles.count) {
                container.repulse.finish = true;
            }
        }
        if (container.repulse.clicking) {
            const repulseDistance = container.retina.repulseModeDistance;
            if (!repulseDistance || repulseDistance < 0) {
                return;
            }
            const repulseRadius = Math.pow(repulseDistance / 6, 3), mouseClickPos = container.interactivity.mouse.clickPosition;
            if (mouseClickPos === undefined) {
                return;
            }
            const range = new esm["b" /* Circle */](mouseClickPos.x, mouseClickPos.y, repulseRadius), query = container.particles.quadTree.query(range, (p) => this.isEnabled(p));
            for (const particle of query) {
                const { dx, dy, distance } = Object(esm["x" /* getDistances */])(mouseClickPos, particle.position), d = distance ** 2, velocity = repulse.speed, force = (-repulseRadius * velocity) / d;
                if (d <= repulseRadius) {
                    container.repulse.particles.push(particle);
                    const vect = esm["h" /* Vector */].create(dx, dy);
                    vect.length = force;
                    particle.velocity.setTo(vect);
                }
            }
        }
        else if (container.repulse.clicking === false) {
            for (const particle of container.repulse.particles) {
                particle.velocity.setTo(particle.initialVelocity);
            }
            container.repulse.particles = [];
        }
    }
    hoverRepulse() {
        const container = this.container, mousePos = container.interactivity.mouse.position, repulseRadius = container.retina.repulseModeDistance;
        if (!repulseRadius || repulseRadius < 0 || !mousePos) {
            return;
        }
        this.processRepulse(mousePos, repulseRadius, new esm["b" /* Circle */](mousePos.x, mousePos.y, repulseRadius));
    }
    processRepulse(position, repulseRadius, area, divRepulse) {
        var _a;
        const container = this.container, query = container.particles.quadTree.query(area, (p) => this.isEnabled(p)), repulseOptions = container.actualOptions.interactivity.modes.repulse;
        if (!repulseOptions) {
            return;
        }
        for (const particle of query) {
            const { dx, dy, distance } = Object(esm["x" /* getDistances */])(particle.position, position), velocity = ((_a = divRepulse === null || divRepulse === void 0 ? void 0 : divRepulse.speed) !== null && _a !== void 0 ? _a : repulseOptions.speed) * repulseOptions.factor, repulseFactor = Object(esm["o" /* clamp */])(Object(esm["y" /* getEasing */])(repulseOptions.easing)(1 - distance / repulseRadius) * velocity, 0, repulseOptions.maxSpeed), normVec = esm["h" /* Vector */].create(distance === 0 ? velocity : (dx / distance) * repulseFactor, distance === 0 ? velocity : (dy / distance) * repulseFactor);
            particle.position.addTo(normVec);
        }
    }
    singleSelectorRepulse(selector, div) {
        const container = this.container, repulse = container.actualOptions.interactivity.modes.repulse;
        if (!repulse) {
            return;
        }
        const query = document.querySelectorAll(selector);
        if (!query.length) {
            return;
        }
        query.forEach((item) => {
            const elem = item, pxRatio = container.retina.pixelRatio, pos = {
                x: (elem.offsetLeft + elem.offsetWidth / 2) * pxRatio,
                y: (elem.offsetTop + elem.offsetHeight / 2) * pxRatio,
            }, repulseRadius = (elem.offsetWidth / 2) * pxRatio, area = div.type === "circle"
                ? new esm["b" /* Circle */](pos.x, pos.y, repulseRadius)
                : new esm["f" /* Rectangle */](elem.offsetLeft * pxRatio, elem.offsetTop * pxRatio, elem.offsetWidth * pxRatio, elem.offsetHeight * pxRatio), divs = repulse.divs, divRepulse = Object(esm["r" /* divMode */])(divs, elem);
            this.processRepulse(pos, repulseRadius, area, divRepulse);
        });
    }
}

// CONCATENATED MODULE: ./node_modules/tsparticles-interaction-external-repulse/esm/Options/Interfaces/IRepulseBase.js


// CONCATENATED MODULE: ./node_modules/tsparticles-interaction-external-repulse/esm/Options/Interfaces/IRepulseDiv.js


// CONCATENATED MODULE: ./node_modules/tsparticles-interaction-external-repulse/esm/Options/Interfaces/IRepulse.js


// CONCATENATED MODULE: ./node_modules/tsparticles-interaction-external-repulse/esm/index.js

async function loadExternalRepulseInteraction(engine) {
    await engine.addInteractor("externalRepulse", (container) => new Repulser_Repulser(engine, container));
}







// CONCATENATED MODULE: ./node_modules/tsparticles-interaction-external-slow/esm/Options/Classes/Slow.js
class Slow {
    constructor() {
        this.factor = 3;
        this.radius = 200;
    }
    load(data) {
        if (!data) {
            return;
        }
        if (data.factor !== undefined) {
            this.factor = data.factor;
        }
        if (data.radius !== undefined) {
            this.radius = data.radius;
        }
    }
}

// CONCATENATED MODULE: ./node_modules/tsparticles-interaction-external-slow/esm/Slower.js


class Slower_Slower extends esm["c" /* ExternalInteractorBase */] {
    constructor(container) {
        super(container);
    }
    clear(particle, delta, force) {
        if (particle.slow.inRange && !force) {
            return;
        }
        particle.slow.factor = 1;
    }
    init() {
        const container = this.container, slow = container.actualOptions.interactivity.modes.slow;
        if (!slow) {
            return;
        }
        container.retina.slowModeRadius = slow.radius * container.retina.pixelRatio;
    }
    async interact() {
    }
    isEnabled(particle) {
        var _a;
        const container = this.container, mouse = container.interactivity.mouse, events = ((_a = particle === null || particle === void 0 ? void 0 : particle.interactivity) !== null && _a !== void 0 ? _a : container.actualOptions.interactivity).events;
        return events.onHover.enable && !!mouse.position && Object(esm["K" /* isInArray */])("slow", events.onHover.mode);
    }
    loadModeOptions(options, ...sources) {
        if (!options.slow) {
            options.slow = new Slow();
        }
        for (const source of sources) {
            options.slow.load(source === null || source === void 0 ? void 0 : source.slow);
        }
    }
    reset(particle) {
        particle.slow.inRange = false;
        const container = this.container, options = container.actualOptions, mousePos = container.interactivity.mouse.position, radius = container.retina.slowModeRadius, slow = options.interactivity.modes.slow;
        if (!slow || !radius || radius < 0 || !mousePos) {
            return;
        }
        const particlePos = particle.getPosition(), dist = Object(esm["w" /* getDistance */])(mousePos, particlePos), proximityFactor = dist / radius, slowFactor = slow.factor;
        if (dist <= radius) {
            particle.slow.inRange = true;
            particle.slow.factor = proximityFactor / slowFactor;
        }
    }
}

// CONCATENATED MODULE: ./node_modules/tsparticles-interaction-external-slow/esm/Options/Interfaces/ISlow.js


// CONCATENATED MODULE: ./node_modules/tsparticles-interaction-external-slow/esm/index.js

async function loadExternalSlowInteraction(engine) {
    await engine.addInteractor("externalSlow", (container) => new Slower_Slower(container));
}



// CONCATENATED MODULE: ./node_modules/tsparticles-shape-image/esm/Utils.js

const currentColorRegex = /(#(?:[0-9a-f]{2}){2,4}|(#[0-9a-f]{3})|(rgb|hsl)a?\((-?\d+%?[,\s]+){2,3}\s*[\d.]+%?\))|currentcolor/gi;
function replaceColorSvg(imageShape, color, opacity) {
    const { svgData } = imageShape;
    if (!svgData) {
        return "";
    }
    const colorStyle = Object(esm["G" /* getStyleFromHsl */])(color, opacity);
    if (svgData.includes("fill")) {
        return svgData.replace(currentColorRegex, () => colorStyle);
    }
    const preFillIndex = svgData.indexOf(">");
    return `${svgData.substring(0, preFillIndex)} fill="${colorStyle}"${svgData.substring(preFillIndex)}`;
}
async function loadImage(image) {
    return new Promise((resolve) => {
        image.loading = true;
        const img = new Image();
        image.element = img;
        img.addEventListener("load", () => {
            image.loading = false;
            resolve();
        });
        img.addEventListener("error", () => {
            image.element = undefined;
            image.error = true;
            image.loading = false;
            console.error(`Error tsParticles - loading image: ${image.source}`);
            resolve();
        });
        img.src = image.source;
    });
}
async function downloadSvgImage(image) {
    if (image.type !== "svg") {
        await loadImage(image);
        return;
    }
    image.loading = true;
    const response = await fetch(image.source);
    if (!response.ok) {
        console.error("Error tsParticles - Image not found");
        image.error = true;
    }
    if (!image.error) {
        image.svgData = await response.text();
    }
    image.loading = false;
}
function replaceImageColor(image, imageData, color, particle) {
    var _a, _b, _c;
    const svgColoredData = replaceColorSvg(image, color, (_b = (_a = particle.opacity) === null || _a === void 0 ? void 0 : _a.value) !== null && _b !== void 0 ? _b : 1), imageRes = {
        color,
        data: Object.assign(Object.assign({}, image), { svgData: svgColoredData }),
        loaded: false,
        ratio: imageData.width / imageData.height,
        replaceColor: (_c = imageData.replaceColor) !== null && _c !== void 0 ? _c : imageData.replace_color,
        source: imageData.src,
    };
    return new Promise((resolve) => {
        const svg = new Blob([svgColoredData], { type: "image/svg+xml" }), domUrl = URL || window.URL || window.webkitURL || window, url = domUrl.createObjectURL(svg), img = new Image();
        img.addEventListener("load", () => {
            imageRes.loaded = true;
            imageRes.element = img;
            resolve(imageRes);
            domUrl.revokeObjectURL(url);
        });
        img.addEventListener("error", async () => {
            domUrl.revokeObjectURL(url);
            const img2 = Object.assign(Object.assign({}, image), { error: false, loading: true });
            await loadImage(img2);
            imageRes.loaded = true;
            imageRes.element = img2.element;
            resolve(imageRes);
        });
        img.src = url;
    });
}

// CONCATENATED MODULE: ./node_modules/tsparticles-shape-image/esm/ImageDrawer.js

class ImageDrawer_ImageDrawer {
    constructor() {
        this._images = [];
    }
    addImage(container, image) {
        const containerImages = this.getImages(container);
        containerImages === null || containerImages === void 0 ? void 0 : containerImages.images.push(image);
    }
    destroy() {
        this._images = [];
    }
    draw(context, particle, radius, opacity) {
        var _a;
        const image = particle.image, element = image === null || image === void 0 ? void 0 : image.element;
        if (!element) {
            return;
        }
        const ratio = (_a = image === null || image === void 0 ? void 0 : image.ratio) !== null && _a !== void 0 ? _a : 1, pos = {
            x: -radius,
            y: -radius,
        };
        context.globalAlpha = opacity;
        context.drawImage(element, pos.x, pos.y, radius * 2, (radius * 2) / ratio);
        context.globalAlpha = 1;
    }
    getImages(container) {
        const containerImages = this._images.find((t) => t.id === container.id);
        if (!containerImages) {
            this._images.push({
                id: container.id,
                images: [],
            });
            return this.getImages(container);
        }
        else {
            return containerImages;
        }
    }
    getSidesCount() {
        return 12;
    }
    loadShape(particle) {
        if (particle.shape !== "image" && particle.shape !== "images") {
            return;
        }
        const container = particle.container, images = this.getImages(container).images, imageData = particle.shapeData, image = images.find((t) => t.source === imageData.src);
        if (!image) {
            this.loadImageShape(container, imageData).then(() => {
                this.loadShape(particle);
            });
        }
    }
    particleInit(container, particle) {
        var _a;
        if (particle.shape !== "image" && particle.shape !== "images") {
            return;
        }
        const images = this.getImages(container).images, imageData = particle.shapeData, color = particle.getFillColor(), replaceColor = (_a = imageData.replaceColor) !== null && _a !== void 0 ? _a : imageData.replace_color, image = images.find((t) => t.source === imageData.src);
        if (!image) {
            return;
        }
        if (image.loading) {
            setTimeout(() => {
                this.particleInit(container, particle);
            });
            return;
        }
        (async () => {
            var _a, _b;
            let imageRes;
            if (image.svgData && color) {
                imageRes = await replaceImageColor(image, imageData, color, particle);
            }
            else {
                imageRes = {
                    color,
                    data: image,
                    element: image.element,
                    loaded: true,
                    ratio: imageData.width / imageData.height,
                    replaceColor: replaceColor,
                    source: imageData.src,
                };
            }
            if (!imageRes.ratio) {
                imageRes.ratio = 1;
            }
            const fill = (_a = imageData.fill) !== null && _a !== void 0 ? _a : particle.fill, close = (_b = imageData.close) !== null && _b !== void 0 ? _b : particle.close, imageShape = {
                image: imageRes,
                fill,
                close,
            };
            particle.image = imageShape.image;
            particle.fill = imageShape.fill;
            particle.close = imageShape.close;
        })();
    }
    async loadImageShape(container, imageShape) {
        var _a;
        const source = imageShape.src;
        if (!source) {
            throw new Error("Error tsParticles - No image.src");
        }
        try {
            const image = {
                source: source,
                type: source.substring(source.length - 3),
                error: false,
                loading: true,
            };
            this.addImage(container, image);
            const imageFunc = ((_a = imageShape.replaceColor) !== null && _a !== void 0 ? _a : imageShape.replace_color) ? downloadSvgImage : loadImage;
            await imageFunc(image);
        }
        catch (_b) {
            throw new Error(`tsParticles error - ${imageShape.src} not found`);
        }
    }
}

// CONCATENATED MODULE: ./node_modules/tsparticles-shape-image/esm/index.js

async function loadImageShape(engine) {
    await engine.addShape(["image", "images"], new ImageDrawer_ImageDrawer());
}

// CONCATENATED MODULE: ./node_modules/tsparticles-updater-life/esm/Options/Classes/LifeDelay.js

class LifeDelay_LifeDelay extends esm["g" /* ValueWithRandom */] {
    constructor() {
        super();
        this.sync = false;
    }
    load(data) {
        if (!data) {
            return;
        }
        super.load(data);
        if (data.sync !== undefined) {
            this.sync = data.sync;
        }
    }
}

// CONCATENATED MODULE: ./node_modules/tsparticles-updater-life/esm/Options/Classes/LifeDuration.js

class LifeDuration_LifeDuration extends esm["g" /* ValueWithRandom */] {
    constructor() {
        super();
        this.random.minimumValue = 0.0001;
        this.sync = false;
    }
    load(data) {
        if (!data) {
            return;
        }
        super.load(data);
        if (data.sync !== undefined) {
            this.sync = data.sync;
        }
    }
}

// CONCATENATED MODULE: ./node_modules/tsparticles-updater-life/esm/Options/Classes/Life.js


class Life_Life {
    constructor() {
        this.count = 0;
        this.delay = new LifeDelay_LifeDelay();
        this.duration = new LifeDuration_LifeDuration();
    }
    load(data) {
        if (!data) {
            return;
        }
        if (data.count !== undefined) {
            this.count = data.count;
        }
        this.delay.load(data.delay);
        this.duration.load(data.duration);
    }
}

// CONCATENATED MODULE: ./node_modules/tsparticles-updater-life/esm/LifeUpdater.js


class LifeUpdater_LifeUpdater {
    constructor(container) {
        this.container = container;
    }
    init(particle) {
        const container = this.container, particlesOptions = particle.options, lifeOptions = particlesOptions.life;
        if (!lifeOptions) {
            return;
        }
        particle.life = {
            delay: container.retina.reduceFactor
                ? ((Object(esm["F" /* getRangeValue */])(lifeOptions.delay.value) * (lifeOptions.delay.sync ? 1 : Object(esm["C" /* getRandom */])())) /
                    container.retina.reduceFactor) *
                    1000
                : 0,
            delayTime: 0,
            duration: container.retina.reduceFactor
                ? ((Object(esm["F" /* getRangeValue */])(lifeOptions.duration.value) * (lifeOptions.duration.sync ? 1 : Object(esm["C" /* getRandom */])())) /
                    container.retina.reduceFactor) *
                    1000
                : 0,
            time: 0,
            count: lifeOptions.count,
        };
        if (particle.life.duration <= 0) {
            particle.life.duration = -1;
        }
        if (particle.life.count <= 0) {
            particle.life.count = -1;
        }
        if (particle.life) {
            particle.spawning = particle.life.delay > 0;
        }
    }
    isEnabled(particle) {
        return !particle.destroyed;
    }
    loadOptions(options, ...sources) {
        if (!options.life) {
            options.life = new Life_Life();
        }
        for (const source of sources) {
            options.life.load(source === null || source === void 0 ? void 0 : source.life);
        }
    }
    update(particle, delta) {
        if (!this.isEnabled(particle) || !particle.life) {
            return;
        }
        const life = particle.life;
        let justSpawned = false;
        if (particle.spawning) {
            life.delayTime += delta.value;
            if (life.delayTime >= particle.life.delay) {
                justSpawned = true;
                particle.spawning = false;
                life.delayTime = 0;
                life.time = 0;
            }
            else {
                return;
            }
        }
        if (life.duration === -1) {
            return;
        }
        if (particle.spawning) {
            return;
        }
        if (justSpawned) {
            life.time = 0;
        }
        else {
            life.time += delta.value;
        }
        if (life.time < life.duration) {
            return;
        }
        life.time = 0;
        if (particle.life.count > 0) {
            particle.life.count--;
        }
        if (particle.life.count === 0) {
            particle.destroy();
            return;
        }
        const canvasSize = this.container.canvas.size, widthRange = Object(esm["Y" /* setRangeValue */])(0, canvasSize.width), heightRange = Object(esm["Y" /* setRangeValue */])(0, canvasSize.width);
        particle.position.x = Object(esm["T" /* randomInRange */])(widthRange);
        particle.position.y = Object(esm["T" /* randomInRange */])(heightRange);
        particle.spawning = true;
        life.delayTime = 0;
        life.time = 0;
        particle.reset();
        const lifeOptions = particle.options.life;
        if (lifeOptions) {
            life.delay = Object(esm["F" /* getRangeValue */])(lifeOptions.delay.value) * 1000;
            life.duration = Object(esm["F" /* getRangeValue */])(lifeOptions.duration.value) * 1000;
        }
    }
}

// CONCATENATED MODULE: ./node_modules/tsparticles-updater-life/esm/index.js

async function loadLifeUpdater(engine) {
    await engine.addParticleUpdater("life", (container) => new LifeUpdater_LifeUpdater(container));
}

// CONCATENATED MODULE: ./node_modules/tsparticles-shape-line/esm/LineDrawer.js
class LineDrawer {
    draw(context, particle, radius) {
        context.moveTo(-radius / 2, 0);
        context.lineTo(radius / 2, 0);
    }
    getSidesCount() {
        return 1;
    }
}

// CONCATENATED MODULE: ./node_modules/tsparticles-shape-line/esm/index.js

async function loadLineShape(engine) {
    await engine.addShape("line", new LineDrawer());
}

// CONCATENATED MODULE: ./node_modules/tsparticles-updater-opacity/esm/OpacityUpdater.js

function checkDestroy(particle, value, minValue, maxValue) {
    switch (particle.options.opacity.animation.destroy) {
        case "max":
            if (value >= maxValue) {
                particle.destroy();
            }
            break;
        case "min":
            if (value <= minValue) {
                particle.destroy();
            }
            break;
    }
}
function updateOpacity(particle, delta) {
    var _a, _b, _c, _d, _e, _f;
    if (!particle.opacity) {
        return;
    }
    const minValue = particle.opacity.min, maxValue = particle.opacity.max, decay = (_a = particle.opacity.decay) !== null && _a !== void 0 ? _a : 1;
    if (particle.destroyed ||
        !particle.opacity.enable ||
        (((_b = particle.opacity.maxLoops) !== null && _b !== void 0 ? _b : 0) > 0 && ((_c = particle.opacity.loops) !== null && _c !== void 0 ? _c : 0) > ((_d = particle.opacity.maxLoops) !== null && _d !== void 0 ? _d : 0))) {
        return;
    }
    switch (particle.opacity.status) {
        case "increasing":
            if (particle.opacity.value >= maxValue) {
                particle.opacity.status = "decreasing";
                if (!particle.opacity.loops) {
                    particle.opacity.loops = 0;
                }
                particle.opacity.loops++;
            }
            else {
                particle.opacity.value += ((_e = particle.opacity.velocity) !== null && _e !== void 0 ? _e : 0) * delta.factor;
            }
            break;
        case "decreasing":
            if (particle.opacity.value <= minValue) {
                particle.opacity.status = "increasing";
                if (!particle.opacity.loops) {
                    particle.opacity.loops = 0;
                }
                particle.opacity.loops++;
            }
            else {
                particle.opacity.value -= ((_f = particle.opacity.velocity) !== null && _f !== void 0 ? _f : 0) * delta.factor;
            }
            break;
    }
    if (particle.opacity.velocity && particle.opacity.decay !== 1) {
        particle.opacity.velocity *= decay;
    }
    checkDestroy(particle, particle.opacity.value, minValue, maxValue);
    if (!particle.destroyed) {
        particle.opacity.value = Object(esm["o" /* clamp */])(particle.opacity.value, minValue, maxValue);
    }
}
class OpacityUpdater_OpacityUpdater {
    constructor(container) {
        this.container = container;
    }
    init(particle) {
        const opacityOptions = particle.options.opacity;
        particle.opacity = {
            enable: opacityOptions.animation.enable,
            max: Object(esm["D" /* getRangeMax */])(opacityOptions.value),
            min: Object(esm["E" /* getRangeMin */])(opacityOptions.value),
            value: Object(esm["F" /* getRangeValue */])(opacityOptions.value),
            loops: 0,
            maxLoops: Object(esm["F" /* getRangeValue */])(opacityOptions.animation.count),
        };
        const opacityAnimation = opacityOptions.animation;
        if (opacityAnimation.enable) {
            particle.opacity.decay = 1 - Object(esm["F" /* getRangeValue */])(opacityAnimation.decay);
            particle.opacity.status = "increasing";
            const opacityRange = opacityOptions.value;
            particle.opacity.min = Object(esm["E" /* getRangeMin */])(opacityRange);
            particle.opacity.max = Object(esm["D" /* getRangeMax */])(opacityRange);
            switch (opacityAnimation.startValue) {
                case "min":
                    particle.opacity.value = particle.opacity.min;
                    particle.opacity.status = "increasing";
                    break;
                case "random":
                    particle.opacity.value = Object(esm["T" /* randomInRange */])(particle.opacity);
                    particle.opacity.status =
                        Object(esm["C" /* getRandom */])() >= 0.5 ? "increasing" : "decreasing";
                    break;
                case "max":
                default:
                    particle.opacity.value = particle.opacity.max;
                    particle.opacity.status = "decreasing";
                    break;
            }
            particle.opacity.velocity =
                (Object(esm["F" /* getRangeValue */])(opacityAnimation.speed) / 100) * this.container.retina.reduceFactor;
            if (!opacityAnimation.sync) {
                particle.opacity.velocity *= Object(esm["C" /* getRandom */])();
            }
        }
        particle.opacity.initialValue = particle.opacity.value;
    }
    isEnabled(particle) {
        var _a, _b, _c, _d;
        return (!particle.destroyed &&
            !particle.spawning &&
            !!particle.opacity &&
            particle.opacity.enable &&
            (((_a = particle.opacity.maxLoops) !== null && _a !== void 0 ? _a : 0) <= 0 ||
                (((_b = particle.opacity.maxLoops) !== null && _b !== void 0 ? _b : 0) > 0 &&
                    ((_c = particle.opacity.loops) !== null && _c !== void 0 ? _c : 0) < ((_d = particle.opacity.maxLoops) !== null && _d !== void 0 ? _d : 0))));
    }
    reset(particle) {
        if (particle.opacity) {
            particle.opacity.loops = 0;
        }
    }
    update(particle, delta) {
        if (!this.isEnabled(particle)) {
            return;
        }
        updateOpacity(particle, delta);
    }
}

// CONCATENATED MODULE: ./node_modules/tsparticles-updater-opacity/esm/index.js

async function loadOpacityUpdater(engine) {
    await engine.addParticleUpdater("opacity", (container) => new OpacityUpdater_OpacityUpdater(container));
}

// CONCATENATED MODULE: ./node_modules/tsparticles-updater-out-modes/esm/Utils.js

function bounceHorizontal(data) {
    if (data.outMode !== "bounce" &&
        data.outMode !== "bounce-horizontal" &&
        data.outMode !== "bounceHorizontal" &&
        data.outMode !== "split") {
        return;
    }
    if (data.bounds.right < 0) {
        data.particle.position.x = data.size + data.offset.x;
    }
    else if (data.bounds.left > data.canvasSize.width) {
        data.particle.position.x = data.canvasSize.width - data.size - data.offset.x;
    }
    const velocity = data.particle.velocity.x;
    let bounced = false;
    if ((data.direction === "right" && data.bounds.right >= data.canvasSize.width && velocity > 0) ||
        (data.direction === "left" && data.bounds.left <= 0 && velocity < 0)) {
        const newVelocity = Object(esm["I" /* getValue */])(data.particle.options.bounce.horizontal);
        data.particle.velocity.x *= -newVelocity;
        bounced = true;
    }
    if (!bounced) {
        return;
    }
    const minPos = data.offset.x + data.size;
    if (data.bounds.right >= data.canvasSize.width) {
        data.particle.position.x = data.canvasSize.width - minPos;
    }
    else if (data.bounds.left <= 0) {
        data.particle.position.x = minPos;
    }
    if (data.outMode === "split") {
        data.particle.destroy();
    }
}
function bounceVertical(data) {
    if (data.outMode !== "bounce" &&
        data.outMode !== "bounce-vertical" &&
        data.outMode !== "bounceVertical" &&
        data.outMode !== "split") {
        return;
    }
    if (data.bounds.bottom < 0) {
        data.particle.position.y = data.size + data.offset.y;
    }
    else if (data.bounds.top > data.canvasSize.height) {
        data.particle.position.y = data.canvasSize.height - data.size - data.offset.y;
    }
    const velocity = data.particle.velocity.y;
    let bounced = false;
    if ((data.direction === "bottom" && data.bounds.bottom >= data.canvasSize.height && velocity > 0) ||
        (data.direction === "top" && data.bounds.top <= 0 && velocity < 0)) {
        const newVelocity = Object(esm["I" /* getValue */])(data.particle.options.bounce.vertical);
        data.particle.velocity.y *= -newVelocity;
        bounced = true;
    }
    if (!bounced) {
        return;
    }
    const minPos = data.offset.y + data.size;
    if (data.bounds.bottom >= data.canvasSize.height) {
        data.particle.position.y = data.canvasSize.height - minPos;
    }
    else if (data.bounds.top <= 0) {
        data.particle.position.y = minPos;
    }
    if (data.outMode === "split") {
        data.particle.destroy();
    }
}

// CONCATENATED MODULE: ./node_modules/tsparticles-updater-out-modes/esm/BounceOutMode.js


class BounceOutMode_BounceOutMode {
    constructor(container) {
        this.container = container;
        this.modes = [
            "bounce",
            "bounce-vertical",
            "bounce-horizontal",
            "bounceVertical",
            "bounceHorizontal",
            "split",
        ];
    }
    update(particle, direction, delta, outMode) {
        if (!this.modes.includes(outMode)) {
            return;
        }
        const container = this.container;
        let handled = false;
        for (const [, plugin] of container.plugins) {
            if (plugin.particleBounce !== undefined) {
                handled = plugin.particleBounce(particle, delta, direction);
            }
            if (handled) {
                break;
            }
        }
        if (handled) {
            return;
        }
        const pos = particle.getPosition(), offset = particle.offset, size = particle.getRadius(), bounds = Object(esm["l" /* calculateBounds */])(pos, size), canvasSize = container.canvas.size;
        bounceHorizontal({ particle, outMode, direction, bounds, canvasSize, offset, size });
        bounceVertical({ particle, outMode, direction, bounds, canvasSize, offset, size });
    }
}

// CONCATENATED MODULE: ./node_modules/tsparticles-updater-out-modes/esm/DestroyOutMode.js

class DestroyOutMode_DestroyOutMode {
    constructor(container) {
        this.container = container;
        this.modes = ["destroy"];
    }
    update(particle, direction, delta, outMode) {
        if (!this.modes.includes(outMode)) {
            return;
        }
        const container = this.container;
        switch (particle.outType) {
            case "normal":
            case "outside":
                if (Object(esm["L" /* isPointInside */])(particle.position, container.canvas.size, esm["h" /* Vector */].origin, particle.getRadius(), direction)) {
                    return;
                }
                break;
            case "inside": {
                const { dx, dy } = Object(esm["x" /* getDistances */])(particle.position, particle.moveCenter);
                const { x: vx, y: vy } = particle.velocity;
                if ((vx < 0 && dx > particle.moveCenter.radius) ||
                    (vy < 0 && dy > particle.moveCenter.radius) ||
                    (vx >= 0 && dx < -particle.moveCenter.radius) ||
                    (vy >= 0 && dy < -particle.moveCenter.radius)) {
                    return;
                }
                break;
            }
        }
        container.particles.remove(particle, undefined, true);
    }
}

// CONCATENATED MODULE: ./node_modules/tsparticles-updater-out-modes/esm/NoneOutMode.js

class NoneOutMode_NoneOutMode {
    constructor(container) {
        this.container = container;
        this.modes = ["none"];
    }
    update(particle, direction, delta, outMode) {
        if (!this.modes.includes(outMode)) {
            return;
        }
        if ((particle.options.move.distance.horizontal &&
            (direction === "left" || direction === "right")) ||
            (particle.options.move.distance.vertical &&
                (direction === "top" || direction === "bottom"))) {
            return;
        }
        const gravityOptions = particle.options.move.gravity, container = this.container;
        const canvasSize = container.canvas.size;
        const pRadius = particle.getRadius();
        if (!gravityOptions.enable) {
            if ((particle.velocity.y > 0 && particle.position.y <= canvasSize.height + pRadius) ||
                (particle.velocity.y < 0 && particle.position.y >= -pRadius) ||
                (particle.velocity.x > 0 && particle.position.x <= canvasSize.width + pRadius) ||
                (particle.velocity.x < 0 && particle.position.x >= -pRadius)) {
                return;
            }
            if (!Object(esm["L" /* isPointInside */])(particle.position, container.canvas.size, esm["h" /* Vector */].origin, pRadius, direction)) {
                container.particles.remove(particle);
            }
        }
        else {
            const position = particle.position;
            if ((!gravityOptions.inverse &&
                position.y > canvasSize.height + pRadius &&
                direction === "bottom") ||
                (gravityOptions.inverse && position.y < -pRadius && direction === "top")) {
                container.particles.remove(particle);
            }
        }
    }
}

// CONCATENATED MODULE: ./node_modules/tsparticles-updater-out-modes/esm/OutOutMode.js

class OutOutMode_OutOutMode {
    constructor(container) {
        this.container = container;
        this.modes = ["out"];
    }
    update(particle, direction, delta, outMode) {
        if (!this.modes.includes(outMode)) {
            return;
        }
        const container = this.container;
        switch (particle.outType) {
            case "inside": {
                const { x: vx, y: vy } = particle.velocity;
                const circVec = esm["h" /* Vector */].origin;
                circVec.length = particle.moveCenter.radius;
                circVec.angle = particle.velocity.angle + Math.PI;
                circVec.addTo(esm["h" /* Vector */].create(particle.moveCenter));
                const { dx, dy } = Object(esm["x" /* getDistances */])(particle.position, circVec);
                if ((vx <= 0 && dx >= 0) || (vy <= 0 && dy >= 0) || (vx >= 0 && dx <= 0) || (vy >= 0 && dy <= 0)) {
                    return;
                }
                particle.position.x = Math.floor(Object(esm["T" /* randomInRange */])({
                    min: 0,
                    max: container.canvas.size.width,
                }));
                particle.position.y = Math.floor(Object(esm["T" /* randomInRange */])({
                    min: 0,
                    max: container.canvas.size.height,
                }));
                const { dx: newDx, dy: newDy } = Object(esm["x" /* getDistances */])(particle.position, particle.moveCenter);
                particle.direction = Math.atan2(-newDy, -newDx);
                particle.velocity.angle = particle.direction;
                break;
            }
            default: {
                if (Object(esm["L" /* isPointInside */])(particle.position, container.canvas.size, esm["h" /* Vector */].origin, particle.getRadius(), direction)) {
                    return;
                }
                switch (particle.outType) {
                    case "outside": {
                        particle.position.x =
                            Math.floor(Object(esm["T" /* randomInRange */])({
                                min: -particle.moveCenter.radius,
                                max: particle.moveCenter.radius,
                            })) + particle.moveCenter.x;
                        particle.position.y =
                            Math.floor(Object(esm["T" /* randomInRange */])({
                                min: -particle.moveCenter.radius,
                                max: particle.moveCenter.radius,
                            })) + particle.moveCenter.y;
                        const { dx, dy } = Object(esm["x" /* getDistances */])(particle.position, particle.moveCenter);
                        if (particle.moveCenter.radius) {
                            particle.direction = Math.atan2(dy, dx);
                            particle.velocity.angle = particle.direction;
                        }
                        break;
                    }
                    case "normal": {
                        const wrap = particle.options.move.warp, canvasSize = container.canvas.size, newPos = {
                            bottom: canvasSize.height + particle.getRadius() + particle.offset.y,
                            left: -particle.getRadius() - particle.offset.x,
                            right: canvasSize.width + particle.getRadius() + particle.offset.x,
                            top: -particle.getRadius() - particle.offset.y,
                        }, sizeValue = particle.getRadius(), nextBounds = Object(esm["l" /* calculateBounds */])(particle.position, sizeValue);
                        if (direction === "right" &&
                            nextBounds.left > canvasSize.width + particle.offset.x) {
                            particle.position.x = newPos.left;
                            particle.initialPosition.x = particle.position.x;
                            if (!wrap) {
                                particle.position.y = Object(esm["C" /* getRandom */])() * canvasSize.height;
                                particle.initialPosition.y = particle.position.y;
                            }
                        }
                        else if (direction === "left" && nextBounds.right < -particle.offset.x) {
                            particle.position.x = newPos.right;
                            particle.initialPosition.x = particle.position.x;
                            if (!wrap) {
                                particle.position.y = Object(esm["C" /* getRandom */])() * canvasSize.height;
                                particle.initialPosition.y = particle.position.y;
                            }
                        }
                        if (direction === "bottom" &&
                            nextBounds.top > canvasSize.height + particle.offset.y) {
                            if (!wrap) {
                                particle.position.x = Object(esm["C" /* getRandom */])() * canvasSize.width;
                                particle.initialPosition.x = particle.position.x;
                            }
                            particle.position.y = newPos.top;
                            particle.initialPosition.y = particle.position.y;
                        }
                        else if (direction === "top" && nextBounds.bottom < -particle.offset.y) {
                            if (!wrap) {
                                particle.position.x = Object(esm["C" /* getRandom */])() * canvasSize.width;
                                particle.initialPosition.x = particle.position.x;
                            }
                            particle.position.y = newPos.bottom;
                            particle.initialPosition.y = particle.position.y;
                        }
                        break;
                    }
                }
                break;
            }
        }
    }
}

// CONCATENATED MODULE: ./node_modules/tsparticles-updater-out-modes/esm/OutOfCanvasUpdater.js




class OutOfCanvasUpdater_OutOfCanvasUpdater {
    constructor(container) {
        this.container = container;
        this.updaters = [
            new BounceOutMode_BounceOutMode(container),
            new DestroyOutMode_DestroyOutMode(container),
            new OutOutMode_OutOutMode(container),
            new NoneOutMode_NoneOutMode(container),
        ];
    }
    init() {
    }
    isEnabled(particle) {
        return !particle.destroyed && !particle.spawning;
    }
    update(particle, delta) {
        var _a, _b, _c, _d;
        const outModes = particle.options.move.outModes;
        this.updateOutMode(particle, delta, (_a = outModes.bottom) !== null && _a !== void 0 ? _a : outModes.default, "bottom");
        this.updateOutMode(particle, delta, (_b = outModes.left) !== null && _b !== void 0 ? _b : outModes.default, "left");
        this.updateOutMode(particle, delta, (_c = outModes.right) !== null && _c !== void 0 ? _c : outModes.default, "right");
        this.updateOutMode(particle, delta, (_d = outModes.top) !== null && _d !== void 0 ? _d : outModes.default, "top");
    }
    updateOutMode(particle, delta, outMode, direction) {
        for (const updater of this.updaters) {
            updater.update(particle, direction, delta, outMode);
        }
    }
}

// CONCATENATED MODULE: ./node_modules/tsparticles-updater-out-modes/esm/index.js

async function loadOutModesUpdater(engine) {
    await engine.addParticleUpdater("outModes", (container) => new OutOfCanvasUpdater_OutOfCanvasUpdater(container));
}

// CONCATENATED MODULE: ./node_modules/tsparticles-move-parallax/esm/ParallaxMover.js

class ParallaxMover_ParallaxMover {
    init() {
    }
    isEnabled(particle) {
        return (!Object(esm["M" /* isSsr */])() &&
            !particle.destroyed &&
            particle.container.actualOptions.interactivity.events.onHover.parallax.enable);
    }
    move(particle) {
        const container = particle.container, options = container.actualOptions;
        if (Object(esm["M" /* isSsr */])() || !options.interactivity.events.onHover.parallax.enable) {
            return;
        }
        const parallaxForce = options.interactivity.events.onHover.parallax.force, mousePos = container.interactivity.mouse.position;
        if (!mousePos) {
            return;
        }
        const canvasCenter = {
            x: container.canvas.size.width / 2,
            y: container.canvas.size.height / 2,
        }, parallaxSmooth = options.interactivity.events.onHover.parallax.smooth, factor = particle.getRadius() / parallaxForce, centerDistance = {
            x: (mousePos.x - canvasCenter.x) * factor,
            y: (mousePos.y - canvasCenter.y) * factor,
        };
        particle.offset.x += (centerDistance.x - particle.offset.x) / parallaxSmooth;
        particle.offset.y += (centerDistance.y - particle.offset.y) / parallaxSmooth;
    }
}

// CONCATENATED MODULE: ./node_modules/tsparticles-move-parallax/esm/index.js

async function loadParallaxMover(engine) {
    engine.addMover("parallax", () => new ParallaxMover_ParallaxMover());
}

// CONCATENATED MODULE: ./node_modules/tsparticles-interaction-particles-attract/esm/Attractor.js

class esm_Attractor_Attractor extends esm["e" /* ParticlesInteractorBase */] {
    constructor(container) {
        super(container);
    }
    clear() {
    }
    init() {
    }
    async interact(p1) {
        var _a;
        const container = this.container, distance = (_a = p1.retina.attractDistance) !== null && _a !== void 0 ? _a : container.retina.attractDistance, pos1 = p1.getPosition(), query = container.particles.quadTree.queryCircle(pos1, distance);
        for (const p2 of query) {
            if (p1 === p2 || !p2.options.move.attract.enable || p2.destroyed || p2.spawning) {
                continue;
            }
            const pos2 = p2.getPosition(), { dx, dy } = Object(esm["x" /* getDistances */])(pos1, pos2), rotate = p1.options.move.attract.rotate, ax = dx / (rotate.x * 1000), ay = dy / (rotate.y * 1000), p1Factor = p2.size.value / p1.size.value, p2Factor = 1 / p1Factor;
            p1.velocity.x -= ax * p1Factor;
            p1.velocity.y -= ay * p1Factor;
            p2.velocity.x += ax * p2Factor;
            p2.velocity.y += ay * p2Factor;
        }
    }
    isEnabled(particle) {
        return particle.options.move.attract.enable;
    }
    reset() {
    }
}

// CONCATENATED MODULE: ./node_modules/tsparticles-interaction-particles-attract/esm/index.js

async function loadParticlesAttractInteraction(engine) {
    await engine.addInteractor("particlesAttract", (container) => new esm_Attractor_Attractor(container));
}

// CONCATENATED MODULE: ./node_modules/tsparticles-interaction-particles-collisions/esm/Absorb.js

function updateAbsorb(p1, r1, p2, r2, delta, pixelRatio) {
    const factor = Object(esm["o" /* clamp */])((p1.options.collisions.absorb.speed * delta.factor) / 10, 0, r2);
    p1.size.value += factor / 2;
    p2.size.value -= factor;
    if (r2 <= pixelRatio) {
        p2.size.value = 0;
        p2.destroy();
    }
}
function absorb(p1, p2, delta, pixelRatio) {
    const r1 = p1.getRadius(), r2 = p2.getRadius();
    if (r1 === undefined && r2 !== undefined) {
        p1.destroy();
    }
    else if (r1 !== undefined && r2 === undefined) {
        p2.destroy();
    }
    else if (r1 !== undefined && r2 !== undefined) {
        if (r1 >= r2) {
            updateAbsorb(p1, r1, p2, r2, delta, pixelRatio);
        }
        else {
            updateAbsorb(p2, r2, p1, r1, delta, pixelRatio);
        }
    }
}

// CONCATENATED MODULE: ./node_modules/tsparticles-interaction-particles-collisions/esm/Bounce.js

function bounce(p1, p2) {
    Object(esm["m" /* circleBounce */])(Object(esm["n" /* circleBounceDataFromParticle */])(p1), Object(esm["n" /* circleBounceDataFromParticle */])(p2));
}

// CONCATENATED MODULE: ./node_modules/tsparticles-interaction-particles-collisions/esm/Destroy.js

function destroy(p1, p2) {
    if (!p1.unbreakable && !p2.unbreakable) {
        bounce(p1, p2);
    }
    if (p1.getRadius() === undefined && p2.getRadius() !== undefined) {
        p1.destroy();
    }
    else if (p1.getRadius() !== undefined && p2.getRadius() === undefined) {
        p2.destroy();
    }
    else if (p1.getRadius() !== undefined && p2.getRadius() !== undefined) {
        const deleteP = p1.getRadius() >= p2.getRadius() ? p1 : p2;
        deleteP.destroy();
    }
}

// CONCATENATED MODULE: ./node_modules/tsparticles-interaction-particles-collisions/esm/ResolveCollision.js



function resolveCollision(p1, p2, delta, pixelRatio) {
    switch (p1.options.collisions.mode) {
        case "absorb": {
            absorb(p1, p2, delta, pixelRatio);
            break;
        }
        case "bounce": {
            bounce(p1, p2);
            break;
        }
        case "destroy": {
            destroy(p1, p2);
            break;
        }
    }
}

// CONCATENATED MODULE: ./node_modules/tsparticles-interaction-particles-collisions/esm/Collider.js


class Collider_Collider extends esm["e" /* ParticlesInteractorBase */] {
    constructor(container) {
        super(container);
    }
    clear() {
    }
    init() {
    }
    async interact(p1, delta) {
        const container = this.container, pos1 = p1.getPosition(), radius1 = p1.getRadius(), query = container.particles.quadTree.queryCircle(pos1, radius1 * 2);
        for (const p2 of query) {
            if (p1 === p2 ||
                !p2.options.collisions.enable ||
                p1.options.collisions.mode !== p2.options.collisions.mode ||
                p2.destroyed ||
                p2.spawning) {
                continue;
            }
            const pos2 = p2.getPosition(), radius2 = p2.getRadius();
            if (Math.abs(Math.round(pos1.z) - Math.round(pos2.z)) > radius1 + radius2) {
                continue;
            }
            const dist = Object(esm["w" /* getDistance */])(pos1, pos2), distP = radius1 + radius2;
            if (dist > distP) {
                continue;
            }
            resolveCollision(p1, p2, delta, container.retina.pixelRatio);
        }
    }
    isEnabled(particle) {
        return particle.options.collisions.enable;
    }
    reset() {
    }
}

// CONCATENATED MODULE: ./node_modules/tsparticles-interaction-particles-collisions/esm/index.js

async function loadParticlesCollisionsInteraction(engine) {
    await engine.addInteractor("particlesCollisions", (container) => new Collider_Collider(container));
}

// CONCATENATED MODULE: ./node_modules/tsparticles-interaction-particles-links/esm/CircleWarp.js

class CircleWarp_CircleWarp extends esm["b" /* Circle */] {
    constructor(x, y, radius, canvasSize) {
        super(x, y, radius);
        this.canvasSize = canvasSize;
        this.canvasSize = Object.assign({}, canvasSize);
    }
    contains(point) {
        if (super.contains(point)) {
            return true;
        }
        const posNE = {
            x: point.x - this.canvasSize.width,
            y: point.y,
        };
        if (super.contains(posNE)) {
            return true;
        }
        const posSE = {
            x: point.x - this.canvasSize.width,
            y: point.y - this.canvasSize.height,
        };
        if (super.contains(posSE)) {
            return true;
        }
        const posSW = {
            x: point.x,
            y: point.y - this.canvasSize.height,
        };
        return super.contains(posSW);
    }
    intersects(range) {
        if (super.intersects(range)) {
            return true;
        }
        const rect = range, circle = range, newPos = {
            x: range.position.x - this.canvasSize.width,
            y: range.position.y - this.canvasSize.height,
        };
        if (circle.radius !== undefined) {
            const biggerCircle = new esm["b" /* Circle */](newPos.x, newPos.y, circle.radius * 2);
            return super.intersects(biggerCircle);
        }
        else if (rect.size !== undefined) {
            const rectSW = new esm["f" /* Rectangle */](newPos.x, newPos.y, rect.size.width * 2, rect.size.height * 2);
            return super.intersects(rectSW);
        }
        return false;
    }
}

// CONCATENATED MODULE: ./node_modules/tsparticles-interaction-particles-links/esm/Options/Classes/LinksShadow.js

class LinksShadow_LinksShadow {
    constructor() {
        this.blur = 5;
        this.color = new esm["d" /* OptionsColor */]();
        this.color.value = "#000";
        this.enable = false;
    }
    load(data) {
        if (!data) {
            return;
        }
        if (data.blur !== undefined) {
            this.blur = data.blur;
        }
        this.color = esm["d" /* OptionsColor */].create(this.color, data.color);
        if (data.enable !== undefined) {
            this.enable = data.enable;
        }
    }
}

// CONCATENATED MODULE: ./node_modules/tsparticles-interaction-particles-links/esm/Options/Classes/LinksTriangle.js

class LinksTriangle_LinksTriangle {
    constructor() {
        this.enable = false;
        this.frequency = 1;
    }
    load(data) {
        if (!data) {
            return;
        }
        if (data.color !== undefined) {
            this.color = esm["d" /* OptionsColor */].create(this.color, data.color);
        }
        if (data.enable !== undefined) {
            this.enable = data.enable;
        }
        if (data.frequency !== undefined) {
            this.frequency = data.frequency;
        }
        if (data.opacity !== undefined) {
            this.opacity = data.opacity;
        }
    }
}

// CONCATENATED MODULE: ./node_modules/tsparticles-interaction-particles-links/esm/Options/Classes/Links.js



class Links_Links {
    constructor() {
        this.blink = false;
        this.color = new esm["d" /* OptionsColor */]();
        this.color.value = "#fff";
        this.consent = false;
        this.distance = 100;
        this.enable = false;
        this.frequency = 1;
        this.opacity = 1;
        this.shadow = new LinksShadow_LinksShadow();
        this.triangles = new LinksTriangle_LinksTriangle();
        this.width = 1;
        this.warp = false;
    }
    load(data) {
        if (!data) {
            return;
        }
        if (data.id !== undefined) {
            this.id = data.id;
        }
        if (data.blink !== undefined) {
            this.blink = data.blink;
        }
        this.color = esm["d" /* OptionsColor */].create(this.color, data.color);
        if (data.consent !== undefined) {
            this.consent = data.consent;
        }
        if (data.distance !== undefined) {
            this.distance = data.distance;
        }
        if (data.enable !== undefined) {
            this.enable = data.enable;
        }
        if (data.frequency !== undefined) {
            this.frequency = data.frequency;
        }
        if (data.opacity !== undefined) {
            this.opacity = data.opacity;
        }
        this.shadow.load(data.shadow);
        this.triangles.load(data.triangles);
        if (data.width !== undefined) {
            this.width = data.width;
        }
        if (data.warp !== undefined) {
            this.warp = data.warp;
        }
    }
}

// CONCATENATED MODULE: ./node_modules/tsparticles-interaction-particles-links/esm/Linker.js



function getLinkDistance(pos1, pos2, optDistance, canvasSize, warp) {
    let distance = Object(esm["w" /* getDistance */])(pos1, pos2);
    if (!warp || distance <= optDistance) {
        return distance;
    }
    const pos2NE = {
        x: pos2.x - canvasSize.width,
        y: pos2.y,
    };
    distance = Object(esm["w" /* getDistance */])(pos1, pos2NE);
    if (distance <= optDistance) {
        return distance;
    }
    const pos2SE = {
        x: pos2.x - canvasSize.width,
        y: pos2.y - canvasSize.height,
    };
    distance = Object(esm["w" /* getDistance */])(pos1, pos2SE);
    if (distance <= optDistance) {
        return distance;
    }
    const pos2SW = {
        x: pos2.x,
        y: pos2.y - canvasSize.height,
    };
    distance = Object(esm["w" /* getDistance */])(pos1, pos2SW);
    return distance;
}
class Linker_Linker extends esm["e" /* ParticlesInteractorBase */] {
    constructor(container) {
        super(container);
        this.linkContainer = container;
    }
    clear() {
    }
    init() {
        this.linkContainer.particles.linksColor = undefined;
        this.linkContainer.particles.linksColors = new Map();
    }
    async interact(p1) {
        var _a;
        if (!p1.options.links) {
            return;
        }
        p1.links = [];
        const pos1 = p1.getPosition(), container = this.container, canvasSize = container.canvas.size;
        if (pos1.x < 0 || pos1.y < 0 || pos1.x > canvasSize.width || pos1.y > canvasSize.height) {
            return;
        }
        const linkOpt1 = p1.options.links, optOpacity = linkOpt1.opacity, optDistance = (_a = p1.retina.linksDistance) !== null && _a !== void 0 ? _a : 0, warp = linkOpt1.warp, range = warp
            ? new CircleWarp_CircleWarp(pos1.x, pos1.y, optDistance, canvasSize)
            : new esm["b" /* Circle */](pos1.x, pos1.y, optDistance), query = container.particles.quadTree.query(range);
        for (const p2 of query) {
            const linkOpt2 = p2.options.links;
            if (p1 === p2 ||
                !(linkOpt2 === null || linkOpt2 === void 0 ? void 0 : linkOpt2.enable) ||
                linkOpt1.id !== linkOpt2.id ||
                p2.spawning ||
                p2.destroyed ||
                !p2.links ||
                p1.links.map((t) => t.destination).indexOf(p2) !== -1 ||
                p2.links.map((t) => t.destination).indexOf(p1) !== -1) {
                continue;
            }
            const pos2 = p2.getPosition();
            if (pos2.x < 0 || pos2.y < 0 || pos2.x > canvasSize.width || pos2.y > canvasSize.height) {
                continue;
            }
            const distance = getLinkDistance(pos1, pos2, optDistance, canvasSize, warp && linkOpt2.warp);
            if (distance > optDistance) {
                return;
            }
            const opacityLine = (1 - distance / optDistance) * optOpacity;
            this.setColor(p1);
            p1.links.push({
                destination: p2,
                opacity: opacityLine,
            });
        }
    }
    isEnabled(particle) {
        var _a;
        return !!((_a = particle.options.links) === null || _a === void 0 ? void 0 : _a.enable);
    }
    loadParticlesOptions(options, ...sources) {
        var _a, _b;
        if (!options.links) {
            options.links = new Links_Links();
        }
        for (const source of sources) {
            options.links.load((_b = (_a = source === null || source === void 0 ? void 0 : source.links) !== null && _a !== void 0 ? _a : source === null || source === void 0 ? void 0 : source.lineLinked) !== null && _b !== void 0 ? _b : source === null || source === void 0 ? void 0 : source.line_linked);
        }
    }
    reset() {
    }
    setColor(p1) {
        if (!p1.options.links) {
            return;
        }
        const container = this.linkContainer, linksOptions = p1.options.links;
        let linkColor = linksOptions.id === undefined
            ? container.particles.linksColor
            : container.particles.linksColors.get(linksOptions.id);
        if (linkColor) {
            return;
        }
        const optColor = linksOptions.color;
        linkColor = Object(esm["B" /* getLinkRandomColor */])(optColor, linksOptions.blink, linksOptions.consent);
        if (linksOptions.id === undefined) {
            container.particles.linksColor = linkColor;
        }
        else {
            container.particles.linksColors.set(linksOptions.id, linkColor);
        }
    }
}

// CONCATENATED MODULE: ./node_modules/tsparticles-interaction-particles-links/esm/interaction.js

async function loadInteraction(engine) {
    await engine.addInteractor("particlesLinks", (container) => new Linker_Linker(container));
}

// CONCATENATED MODULE: ./node_modules/tsparticles-interaction-particles-links/esm/Utils.js

function drawLinkLine(context, width, begin, end, maxDistance, canvasSize, warp, backgroundMask, composite, colorLine, opacity, shadow) {
    let drawn = false;
    if (Object(esm["w" /* getDistance */])(begin, end) <= maxDistance) {
        Object(esm["t" /* drawLine */])(context, begin, end);
        drawn = true;
    }
    else if (warp) {
        let pi1;
        let pi2;
        const endNE = {
            x: end.x - canvasSize.width,
            y: end.y,
        };
        const d1 = Object(esm["x" /* getDistances */])(begin, endNE);
        if (d1.distance <= maxDistance) {
            const yi = begin.y - (d1.dy / d1.dx) * begin.x;
            pi1 = { x: 0, y: yi };
            pi2 = { x: canvasSize.width, y: yi };
        }
        else {
            const endSW = {
                x: end.x,
                y: end.y - canvasSize.height,
            };
            const d2 = Object(esm["x" /* getDistances */])(begin, endSW);
            if (d2.distance <= maxDistance) {
                const yi = begin.y - (d2.dy / d2.dx) * begin.x;
                const xi = -yi / (d2.dy / d2.dx);
                pi1 = { x: xi, y: 0 };
                pi2 = { x: xi, y: canvasSize.height };
            }
            else {
                const endSE = {
                    x: end.x - canvasSize.width,
                    y: end.y - canvasSize.height,
                };
                const d3 = Object(esm["x" /* getDistances */])(begin, endSE);
                if (d3.distance <= maxDistance) {
                    const yi = begin.y - (d3.dy / d3.dx) * begin.x;
                    const xi = -yi / (d3.dy / d3.dx);
                    pi1 = { x: xi, y: yi };
                    pi2 = { x: pi1.x + canvasSize.width, y: pi1.y + canvasSize.height };
                }
            }
        }
        if (pi1 && pi2) {
            Object(esm["t" /* drawLine */])(context, begin, pi1);
            Object(esm["t" /* drawLine */])(context, end, pi2);
            drawn = true;
        }
    }
    if (!drawn) {
        return;
    }
    context.lineWidth = width;
    if (backgroundMask) {
        context.globalCompositeOperation = composite;
    }
    context.strokeStyle = Object(esm["H" /* getStyleFromRgb */])(colorLine, opacity);
    if (shadow.enable) {
        const shadowColor = Object(esm["V" /* rangeColorToRgb */])(shadow.color);
        if (shadowColor) {
            context.shadowBlur = shadow.blur;
            context.shadowColor = Object(esm["H" /* getStyleFromRgb */])(shadowColor);
        }
    }
    context.stroke();
}
function drawLinkTriangle(context, pos1, pos2, pos3, backgroundMask, composite, colorTriangle, opacityTriangle) {
    Object(esm["u" /* drawTriangle */])(context, pos1, pos2, pos3);
    if (backgroundMask) {
        context.globalCompositeOperation = composite;
    }
    context.fillStyle = Object(esm["H" /* getStyleFromRgb */])(colorTriangle, opacityTriangle);
    context.fill();
}

// CONCATENATED MODULE: ./node_modules/tsparticles-interaction-particles-links/esm/LinkInstance.js


function getLinkKey(ids) {
    ids.sort((a, b) => a - b);
    return ids.join("_");
}
function setLinkFrequency(particles, dictionary) {
    const key = getLinkKey(particles.map((t) => t.id));
    let res = dictionary.get(key);
    if (res === undefined) {
        res = Object(esm["C" /* getRandom */])();
        dictionary.set(key, res);
    }
    return res;
}
class LinkInstance_LinkInstance {
    constructor(container) {
        this.container = container;
        this._freqs = {
            links: new Map(),
            triangles: new Map(),
        };
    }
    drawParticle(context, particle) {
        var _a;
        const pOptions = particle.options;
        if (!particle.links || particle.links.length <= 0) {
            return;
        }
        const p1Links = particle.links.filter((l) => pOptions.links && this.getLinkFrequency(particle, l.destination) <= pOptions.links.frequency);
        for (const link of p1Links) {
            this.drawTriangles(pOptions, particle, link, p1Links);
            if (link.opacity > 0 && ((_a = particle.retina.linksWidth) !== null && _a !== void 0 ? _a : 0) > 0) {
                this.drawLinkLine(particle, link);
            }
        }
    }
    async init() {
        this._freqs.links = new Map();
        this._freqs.triangles = new Map();
    }
    particleCreated(particle) {
        particle.links = [];
        if (!particle.options.links) {
            return;
        }
        const ratio = this.container.retina.pixelRatio;
        particle.retina.linksDistance = particle.options.links.distance * ratio;
        particle.retina.linksWidth = particle.options.links.width * ratio;
    }
    particleDestroyed(particle) {
        particle.links = [];
    }
    drawLinkLine(p1, link) {
        const container = this.container, options = container.actualOptions, p2 = link.destination, pos1 = p1.getPosition(), pos2 = p2.getPosition();
        let opacity = link.opacity;
        container.canvas.draw((ctx) => {
            var _a, _b, _c;
            if (!p1.options.links) {
                return;
            }
            let colorLine;
            const twinkle = (_a = p1.options.twinkle) === null || _a === void 0 ? void 0 : _a.lines;
            if (twinkle === null || twinkle === void 0 ? void 0 : twinkle.enable) {
                const twinkleFreq = twinkle.frequency, twinkleRgb = Object(esm["V" /* rangeColorToRgb */])(twinkle.color), twinkling = Object(esm["C" /* getRandom */])() < twinkleFreq;
                if (twinkling && twinkleRgb) {
                    colorLine = twinkleRgb;
                    opacity = Object(esm["F" /* getRangeValue */])(twinkle.opacity);
                }
            }
            if (!colorLine) {
                const linksOptions = p1.options.links, linkColor = (linksOptions === null || linksOptions === void 0 ? void 0 : linksOptions.id) !== undefined
                    ? container.particles.linksColors.get(linksOptions.id)
                    : container.particles.linksColor;
                colorLine = Object(esm["A" /* getLinkColor */])(p1, p2, linkColor);
            }
            if (!colorLine) {
                return;
            }
            const width = (_b = p1.retina.linksWidth) !== null && _b !== void 0 ? _b : 0, maxDistance = (_c = p1.retina.linksDistance) !== null && _c !== void 0 ? _c : 0;
            drawLinkLine(ctx, width, pos1, pos2, maxDistance, container.canvas.size, p1.options.links.warp, options.backgroundMask.enable, options.backgroundMask.composite, colorLine, opacity, p1.options.links.shadow);
        });
    }
    drawLinkTriangle(p1, link1, link2) {
        var _a;
        if (!p1.options.links) {
            return;
        }
        const container = this.container, options = container.actualOptions, p2 = link1.destination, p3 = link2.destination, triangleOptions = p1.options.links.triangles, opacityTriangle = (_a = triangleOptions.opacity) !== null && _a !== void 0 ? _a : (link1.opacity + link2.opacity) / 2;
        if (opacityTriangle <= 0) {
            return;
        }
        container.canvas.draw((ctx) => {
            var _a;
            const pos1 = p1.getPosition(), pos2 = p2.getPosition(), pos3 = p3.getPosition(), linksDistance = (_a = p1.retina.linksDistance) !== null && _a !== void 0 ? _a : 0;
            if (Object(esm["w" /* getDistance */])(pos1, pos2) > linksDistance ||
                Object(esm["w" /* getDistance */])(pos3, pos2) > linksDistance ||
                Object(esm["w" /* getDistance */])(pos3, pos1) > linksDistance) {
                return;
            }
            let colorTriangle = Object(esm["V" /* rangeColorToRgb */])(triangleOptions.color);
            if (!colorTriangle) {
                const linksOptions = p1.options.links, linkColor = (linksOptions === null || linksOptions === void 0 ? void 0 : linksOptions.id) !== undefined
                    ? container.particles.linksColors.get(linksOptions.id)
                    : container.particles.linksColor;
                colorTriangle = Object(esm["A" /* getLinkColor */])(p1, p2, linkColor);
            }
            if (!colorTriangle) {
                return;
            }
            drawLinkTriangle(ctx, pos1, pos2, pos3, options.backgroundMask.enable, options.backgroundMask.composite, colorTriangle, opacityTriangle);
        });
    }
    drawTriangles(options, p1, link, p1Links) {
        var _a, _b, _c;
        const p2 = link.destination;
        if (!(((_a = options.links) === null || _a === void 0 ? void 0 : _a.triangles.enable) && ((_b = p2.options.links) === null || _b === void 0 ? void 0 : _b.triangles.enable))) {
            return;
        }
        const vertices = (_c = p2.links) === null || _c === void 0 ? void 0 : _c.filter((t) => {
            const linkFreq = this.getLinkFrequency(p2, t.destination);
            return (p2.options.links &&
                linkFreq <= p2.options.links.frequency &&
                p1Links.findIndex((l) => l.destination === t.destination) >= 0);
        });
        if (!(vertices === null || vertices === void 0 ? void 0 : vertices.length)) {
            return;
        }
        for (const vertex of vertices) {
            const p3 = vertex.destination, triangleFreq = this.getTriangleFrequency(p1, p2, p3);
            if (triangleFreq > options.links.triangles.frequency) {
                continue;
            }
            this.drawLinkTriangle(p1, link, vertex);
        }
    }
    getLinkFrequency(p1, p2) {
        return setLinkFrequency([p1, p2], this._freqs.links);
    }
    getTriangleFrequency(p1, p2, p3) {
        return setLinkFrequency([p1, p2, p3], this._freqs.triangles);
    }
}

// CONCATENATED MODULE: ./node_modules/tsparticles-interaction-particles-links/esm/plugin.js

class plugin_LinksPlugin {
    constructor() {
        this.id = "links";
    }
    getPlugin(container) {
        return new LinkInstance_LinkInstance(container);
    }
    loadOptions() {
    }
    needsPlugin() {
        return true;
    }
}
async function loadPlugin(engine) {
    const plugin = new plugin_LinksPlugin();
    await engine.addPlugin(plugin);
}

// CONCATENATED MODULE: ./node_modules/tsparticles-interaction-particles-links/esm/Options/Interfaces/ILinks.js


// CONCATENATED MODULE: ./node_modules/tsparticles-interaction-particles-links/esm/Options/Interfaces/ILinksShadow.js


// CONCATENATED MODULE: ./node_modules/tsparticles-interaction-particles-links/esm/Options/Interfaces/ILinksTriangle.js


// CONCATENATED MODULE: ./node_modules/tsparticles-interaction-particles-links/esm/index.js


async function loadParticlesLinksInteraction(engine) {
    await loadInteraction(engine);
    await loadPlugin(engine);
}







// CONCATENATED MODULE: ./node_modules/tsparticles-shape-polygon/esm/PolygonDrawerBase.js

class PolygonDrawerBase_PolygonDrawerBase {
    draw(context, particle, radius) {
        const start = this.getCenter(particle, radius), side = this.getSidesData(particle, radius), sideCount = side.count.numerator * side.count.denominator, decimalSides = side.count.numerator / side.count.denominator, interiorAngleDegrees = (180 * (decimalSides - 2)) / decimalSides, interiorAngle = Math.PI - (Math.PI * interiorAngleDegrees) / 180;
        if (!context) {
            return;
        }
        context.beginPath();
        context.translate(start.x, start.y);
        context.moveTo(0, 0);
        for (let i = 0; i < sideCount; i++) {
            context.lineTo(side.length, 0);
            context.translate(side.length, 0);
            context.rotate(interiorAngle);
        }
    }
    getSidesCount(particle) {
        var _a, _b;
        const polygon = particle.shapeData, sides = Math.round(Object(esm["F" /* getRangeValue */])((_b = (_a = polygon === null || polygon === void 0 ? void 0 : polygon.sides) !== null && _a !== void 0 ? _a : polygon === null || polygon === void 0 ? void 0 : polygon.nb_sides) !== null && _b !== void 0 ? _b : 5));
        return sides;
    }
}

// CONCATENATED MODULE: ./node_modules/tsparticles-shape-polygon/esm/PolygonDrawer.js

class PolygonDrawer_PolygonDrawer extends PolygonDrawerBase_PolygonDrawerBase {
    getCenter(particle, radius) {
        return {
            x: -radius / (particle.sides / 3.5),
            y: -radius / (2.66 / 3.5),
        };
    }
    getSidesData(particle, radius) {
        const sides = particle.sides;
        return {
            count: {
                denominator: 1,
                numerator: sides,
            },
            length: (radius * 2.66) / (sides / 3),
        };
    }
}

// CONCATENATED MODULE: ./node_modules/tsparticles-shape-polygon/esm/TriangleDrawer.js

class TriangleDrawer_TriangleDrawer extends PolygonDrawerBase_PolygonDrawerBase {
    getCenter(particle, radius) {
        return {
            x: -radius,
            y: radius / 1.66,
        };
    }
    getSidesCount() {
        return 3;
    }
    getSidesData(particle, radius) {
        return {
            count: {
                denominator: 2,
                numerator: 3,
            },
            length: radius * 2,
        };
    }
}

// CONCATENATED MODULE: ./node_modules/tsparticles-shape-polygon/esm/index.js


async function loadGenericPolygonShape(engine) {
    await engine.addShape("polygon", new PolygonDrawer_PolygonDrawer());
}
async function loadTriangleShape(engine) {
    await engine.addShape("triangle", new TriangleDrawer_TriangleDrawer());
}
async function loadPolygonShape(engine) {
    await loadGenericPolygonShape(engine);
    await loadTriangleShape(engine);
}

// CONCATENATED MODULE: ./node_modules/tsparticles-updater-size/esm/SizeUpdater.js

function SizeUpdater_checkDestroy(particle, value, minValue, maxValue) {
    switch (particle.options.size.animation.destroy) {
        case "max":
            if (value >= maxValue) {
                particle.destroy();
            }
            break;
        case "min":
            if (value <= minValue) {
                particle.destroy();
            }
            break;
    }
}
function updateSize(particle, delta) {
    var _a, _b, _c, _d, _e;
    const sizeVelocity = ((_a = particle.size.velocity) !== null && _a !== void 0 ? _a : 0) * delta.factor, minValue = particle.size.min, maxValue = particle.size.max, decay = (_b = particle.size.decay) !== null && _b !== void 0 ? _b : 1;
    if (particle.destroyed ||
        !particle.size.enable ||
        (((_c = particle.size.maxLoops) !== null && _c !== void 0 ? _c : 0) > 0 && ((_d = particle.size.loops) !== null && _d !== void 0 ? _d : 0) > ((_e = particle.size.maxLoops) !== null && _e !== void 0 ? _e : 0))) {
        return;
    }
    switch (particle.size.status) {
        case "increasing":
            if (particle.size.value >= maxValue) {
                particle.size.status = "decreasing";
                if (!particle.size.loops) {
                    particle.size.loops = 0;
                }
                particle.size.loops++;
            }
            else {
                particle.size.value += sizeVelocity;
            }
            break;
        case "decreasing":
            if (particle.size.value <= minValue) {
                particle.size.status = "increasing";
                if (!particle.size.loops) {
                    particle.size.loops = 0;
                }
                particle.size.loops++;
            }
            else {
                particle.size.value -= sizeVelocity;
            }
    }
    if (particle.size.velocity && decay !== 1) {
        particle.size.velocity *= decay;
    }
    SizeUpdater_checkDestroy(particle, particle.size.value, minValue, maxValue);
    if (!particle.destroyed) {
        particle.size.value = Object(esm["o" /* clamp */])(particle.size.value, minValue, maxValue);
    }
}
class SizeUpdater_SizeUpdater {
    init(particle) {
        var _a;
        const container = particle.container, sizeOptions = particle.options.size, sizeAnimation = sizeOptions.animation;
        if (sizeAnimation.enable) {
            particle.size.velocity =
                (((_a = particle.retina.sizeAnimationSpeed) !== null && _a !== void 0 ? _a : container.retina.sizeAnimationSpeed) / 100) *
                    container.retina.reduceFactor;
            if (!sizeAnimation.sync) {
                particle.size.velocity *= Object(esm["C" /* getRandom */])();
            }
        }
    }
    isEnabled(particle) {
        var _a, _b, _c, _d;
        return (!particle.destroyed &&
            !particle.spawning &&
            particle.size.enable &&
            (((_a = particle.size.maxLoops) !== null && _a !== void 0 ? _a : 0) <= 0 ||
                (((_b = particle.size.maxLoops) !== null && _b !== void 0 ? _b : 0) > 0 && ((_c = particle.size.loops) !== null && _c !== void 0 ? _c : 0) < ((_d = particle.size.maxLoops) !== null && _d !== void 0 ? _d : 0))));
    }
    reset(particle) {
        particle.size.loops = 0;
    }
    update(particle, delta) {
        if (!this.isEnabled(particle)) {
            return;
        }
        updateSize(particle, delta);
    }
}

// CONCATENATED MODULE: ./node_modules/tsparticles-updater-size/esm/index.js

async function loadSizeUpdater(engine) {
    await engine.addParticleUpdater("size", () => new SizeUpdater_SizeUpdater());
}

// CONCATENATED MODULE: ./node_modules/tsparticles-shape-square/esm/SquareDrawer.js
const fixFactor = Math.sqrt(2);
class SquareDrawer {
    draw(context, particle, radius) {
        context.rect(-radius / fixFactor, -radius / fixFactor, (radius * 2) / fixFactor, (radius * 2) / fixFactor);
    }
    getSidesCount() {
        return 4;
    }
}

// CONCATENATED MODULE: ./node_modules/tsparticles-shape-square/esm/index.js

async function loadSquareShape(engine) {
    const drawer = new SquareDrawer();
    await engine.addShape(["edge", "square"], drawer);
}

// CONCATENATED MODULE: ./node_modules/tsparticles-shape-star/esm/StarDrawer.js

class StarDrawer_StarDrawer {
    draw(context, particle, radius) {
        var _a;
        const sides = particle.sides, inset = (_a = particle.starInset) !== null && _a !== void 0 ? _a : 2;
        context.moveTo(0, 0 - radius);
        for (let i = 0; i < sides; i++) {
            context.rotate(Math.PI / sides);
            context.lineTo(0, 0 - radius * inset);
            context.rotate(Math.PI / sides);
            context.lineTo(0, 0 - radius);
        }
    }
    getSidesCount(particle) {
        var _a, _b;
        const star = particle.shapeData;
        return Math.round(Object(esm["F" /* getRangeValue */])((_b = (_a = star === null || star === void 0 ? void 0 : star.sides) !== null && _a !== void 0 ? _a : star === null || star === void 0 ? void 0 : star.nb_sides) !== null && _b !== void 0 ? _b : 5));
    }
    particleInit(container, particle) {
        var _a;
        const star = particle.shapeData, inset = Object(esm["F" /* getRangeValue */])((_a = star === null || star === void 0 ? void 0 : star.inset) !== null && _a !== void 0 ? _a : 2);
        particle.starInset = inset;
    }
}

// CONCATENATED MODULE: ./node_modules/tsparticles-shape-star/esm/index.js

async function loadStarShape(engine) {
    await engine.addShape("star", new StarDrawer_StarDrawer());
}

// CONCATENATED MODULE: ./node_modules/tsparticles-updater-stroke-color/esm/StrokeColorUpdater.js

function StrokeColorUpdater_updateColorValue(delta, value, valueAnimation, max, decrease) {
    var _a, _b;
    const colorValue = value;
    if (!colorValue ||
        !colorValue.enable ||
        (colorValue.loops !== undefined &&
            colorValue.maxLoops !== undefined &&
            colorValue.maxLoops > 0 &&
            colorValue.loops >= colorValue.maxLoops)) {
        return;
    }
    const offset = Object(esm["T" /* randomInRange */])(valueAnimation.offset), velocity = ((_a = value.velocity) !== null && _a !== void 0 ? _a : 0) * delta.factor + offset * 3.6, decay = (_b = value.decay) !== null && _b !== void 0 ? _b : 1;
    if (!decrease || colorValue.status === "increasing") {
        colorValue.value += velocity;
        if (colorValue.value > max) {
            if (!colorValue.loops) {
                colorValue.loops = 0;
            }
            colorValue.loops++;
            if (decrease) {
                colorValue.status = "decreasing";
                colorValue.value -= colorValue.value % max;
            }
        }
    }
    else {
        colorValue.value -= velocity;
        if (colorValue.value < 0) {
            if (!colorValue.loops) {
                colorValue.loops = 0;
            }
            colorValue.loops++;
            colorValue.status = "increasing";
            colorValue.value += colorValue.value;
        }
    }
    if (colorValue.velocity && decay !== 1) {
        colorValue.velocity *= decay;
    }
    if (colorValue.value > max) {
        colorValue.value %= max;
    }
}
function updateStrokeColor(particle, delta) {
    if (!particle.strokeColor || !particle.strokeAnimation) {
        return;
    }
    const h = particle.strokeColor.h;
    if (h) {
        StrokeColorUpdater_updateColorValue(delta, h, particle.strokeAnimation.h, 360, false);
    }
    const s = particle.strokeColor.s;
    if (s) {
        StrokeColorUpdater_updateColorValue(delta, s, particle.strokeAnimation.s, 100, true);
    }
    const l = particle.strokeColor.l;
    if (l) {
        StrokeColorUpdater_updateColorValue(delta, l, particle.strokeAnimation.l, 100, true);
    }
}
class StrokeColorUpdater_StrokeColorUpdater {
    constructor(container) {
        this.container = container;
    }
    init(particle) {
        var _a, _b, _c;
        const container = this.container;
        const stroke = Object(esm["O" /* itemFromSingleOrMultiple */])(particle.options.stroke, particle.id, particle.options.reduceDuplicates);
        particle.strokeWidth = Object(esm["F" /* getRangeValue */])(stroke.width) * container.retina.pixelRatio;
        particle.strokeOpacity = Object(esm["F" /* getRangeValue */])((_a = stroke.opacity) !== null && _a !== void 0 ? _a : 1);
        particle.strokeAnimation = (_b = stroke.color) === null || _b === void 0 ? void 0 : _b.animation;
        const strokeHslColor = (_c = Object(esm["U" /* rangeColorToHsl */])(stroke.color)) !== null && _c !== void 0 ? _c : particle.getFillColor();
        if (strokeHslColor) {
            particle.strokeColor = Object(esm["z" /* getHslAnimationFromHsl */])(strokeHslColor, particle.strokeAnimation, container.retina.reduceFactor);
        }
    }
    isEnabled(particle) {
        var _a, _b, _c;
        const color = particle.strokeAnimation;
        return (!particle.destroyed &&
            !particle.spawning &&
            !!color &&
            ((((_a = particle.strokeColor) === null || _a === void 0 ? void 0 : _a.h.value) !== undefined && particle.strokeColor.h.enable) ||
                (((_b = particle.strokeColor) === null || _b === void 0 ? void 0 : _b.s.value) !== undefined && particle.strokeColor.s.enable) ||
                (((_c = particle.strokeColor) === null || _c === void 0 ? void 0 : _c.l.value) !== undefined && particle.strokeColor.l.enable)));
    }
    update(particle, delta) {
        if (!this.isEnabled(particle)) {
            return;
        }
        updateStrokeColor(particle, delta);
    }
}

// CONCATENATED MODULE: ./node_modules/tsparticles-updater-stroke-color/esm/index.js

async function loadStrokeColorUpdater(engine) {
    await engine.addParticleUpdater("strokeColor", (container) => new StrokeColorUpdater_StrokeColorUpdater(container));
}

// CONCATENATED MODULE: ./node_modules/tsparticles-shape-text/esm/TextDrawer.js

const validTypes = ["text", "character", "char"];
class TextDrawer_TextDrawer {
    draw(context, particle, radius, opacity) {
        var _a, _b, _c;
        const character = particle.shapeData;
        if (character === undefined) {
            return;
        }
        const textData = character.value;
        if (textData === undefined) {
            return;
        }
        const textParticle = particle;
        if (textParticle.text === undefined) {
            textParticle.text = Object(esm["O" /* itemFromSingleOrMultiple */])(textData, particle.randomIndexData);
        }
        const text = textParticle.text, style = (_a = character.style) !== null && _a !== void 0 ? _a : "", weight = (_b = character.weight) !== null && _b !== void 0 ? _b : "400", size = Math.round(radius) * 2, font = (_c = character.font) !== null && _c !== void 0 ? _c : "Verdana", fill = particle.fill, offsetX = (text.length * radius) / 2;
        context.font = `${style} ${weight} ${size}px "${font}"`;
        const pos = {
            x: -offsetX,
            y: radius / 2,
        };
        context.globalAlpha = opacity;
        if (fill) {
            context.fillText(text, pos.x, pos.y);
        }
        else {
            context.strokeText(text, pos.x, pos.y);
        }
        context.globalAlpha = 1;
    }
    getSidesCount() {
        return 12;
    }
    async init(container) {
        const options = container.actualOptions;
        if (validTypes.find((t) => Object(esm["K" /* isInArray */])(t, options.particles.shape.type))) {
            const shapeOptions = validTypes
                .map((t) => options.particles.shape.options[t])
                .find((t) => !!t), promises = [];
            Object(esm["v" /* executeOnSingleOrMultiple */])(shapeOptions, (shape) => {
                promises.push(Object(esm["P" /* loadFont */])(shape.font, shape.weight));
            });
            await Promise.all(promises);
        }
    }
}

// CONCATENATED MODULE: ./node_modules/tsparticles-shape-text/esm/index.js

async function loadTextShape(engine) {
    await engine.addShape(validTypes, new TextDrawer_TextDrawer());
}

// CONCATENATED MODULE: ./node_modules/tsparticles-slim/esm/index.js






























async function loadSlim(engine) {
    await loadBaseMover(engine);
    await loadParallaxMover(engine);
    await loadExternalAttractInteraction(engine);
    await loadExternalBounceInteraction(engine);
    await loadExternalBubbleInteraction(engine);
    await loadExternalConnectInteraction(engine);
    await loadExternalGrabInteraction(engine);
    await loadExternalPauseInteraction(engine);
    await loadExternalPushInteraction(engine);
    await loadExternalRemoveInteraction(engine);
    await loadExternalRepulseInteraction(engine);
    await loadExternalSlowInteraction(engine);
    await loadParticlesAttractInteraction(engine);
    await loadParticlesCollisionsInteraction(engine);
    await loadParticlesLinksInteraction(engine);
    await loadCircleShape(engine);
    await loadImageShape(engine);
    await loadLineShape(engine);
    await loadPolygonShape(engine);
    await loadSquareShape(engine);
    await loadStarShape(engine);
    await loadTextShape(engine);
    await loadLifeUpdater(engine);
    await loadOpacityUpdater(engine);
    await loadSizeUpdater(engine);
    await loadAngleUpdater(engine);
    await loadColorUpdater(engine);
    await loadStrokeColorUpdater(engine);
    await loadOutModesUpdater(engine);
    await initPjs(engine);
}

// CONCATENATED MODULE: ./node_modules/tsparticles-updater-tilt/esm/Options/Classes/TiltAnimation.js

class TiltAnimation_TiltAnimation {
    constructor() {
        this.enable = false;
        this.speed = 0;
        this.decay = 0;
        this.sync = false;
    }
    load(data) {
        if (!data) {
            return;
        }
        if (data.enable !== undefined) {
            this.enable = data.enable;
        }
        if (data.speed !== undefined) {
            this.speed = Object(esm["Y" /* setRangeValue */])(data.speed);
        }
        if (data.decay !== undefined) {
            this.decay = Object(esm["Y" /* setRangeValue */])(data.decay);
        }
        if (data.sync !== undefined) {
            this.sync = data.sync;
        }
    }
}

// CONCATENATED MODULE: ./node_modules/tsparticles-updater-tilt/esm/Options/Classes/Tilt.js


class Tilt_Tilt extends esm["g" /* ValueWithRandom */] {
    constructor() {
        super();
        this.animation = new TiltAnimation_TiltAnimation();
        this.direction = "clockwise";
        this.enable = false;
        this.value = 0;
    }
    load(data) {
        super.load(data);
        if (!data) {
            return;
        }
        this.animation.load(data.animation);
        if (data.direction !== undefined) {
            this.direction = data.direction;
        }
        if (data.enable !== undefined) {
            this.enable = data.enable;
        }
    }
}

// CONCATENATED MODULE: ./node_modules/tsparticles-updater-tilt/esm/TiltUpdater.js


function updateTilt(particle, delta) {
    var _a, _b;
    if (!particle.tilt || !particle.options.tilt) {
        return;
    }
    const tilt = particle.options.tilt, tiltAnimation = tilt.animation, speed = ((_a = particle.tilt.velocity) !== null && _a !== void 0 ? _a : 0) * delta.factor, max = 2 * Math.PI, decay = (_b = particle.tilt.decay) !== null && _b !== void 0 ? _b : 1;
    if (!tiltAnimation.enable) {
        return;
    }
    switch (particle.tilt.status) {
        case "increasing":
            particle.tilt.value += speed;
            if (particle.tilt.value > max) {
                particle.tilt.value -= max;
            }
            break;
        case "decreasing":
        default:
            particle.tilt.value -= speed;
            if (particle.tilt.value < 0) {
                particle.tilt.value += max;
            }
            break;
    }
    if (particle.tilt.velocity && decay !== 1) {
        particle.tilt.velocity *= decay;
    }
}
class TiltUpdater_TiltUpdater {
    constructor(container) {
        this.container = container;
    }
    getTransformValues(particle) {
        var _a;
        const tilt = ((_a = particle.tilt) === null || _a === void 0 ? void 0 : _a.enable) && particle.tilt;
        return {
            b: tilt ? Math.cos(tilt.value) * tilt.cosDirection : undefined,
            c: tilt ? Math.sin(tilt.value) * tilt.sinDirection : undefined,
        };
    }
    init(particle) {
        var _a;
        const tiltOptions = particle.options.tilt;
        if (!tiltOptions) {
            return;
        }
        particle.tilt = {
            enable: tiltOptions.enable,
            value: (Object(esm["F" /* getRangeValue */])(tiltOptions.value) * Math.PI) / 180,
            sinDirection: Object(esm["C" /* getRandom */])() >= 0.5 ? 1 : -1,
            cosDirection: Object(esm["C" /* getRandom */])() >= 0.5 ? 1 : -1,
        };
        let tiltDirection = tiltOptions.direction;
        if (tiltDirection === "random") {
            const index = Math.floor(Object(esm["C" /* getRandom */])() * 2);
            tiltDirection = index > 0 ? "counter-clockwise" : "clockwise";
        }
        switch (tiltDirection) {
            case "counter-clockwise":
            case "counterClockwise":
                particle.tilt.status = "decreasing";
                break;
            case "clockwise":
                particle.tilt.status = "increasing";
                break;
        }
        const tiltAnimation = (_a = particle.options.tilt) === null || _a === void 0 ? void 0 : _a.animation;
        if (tiltAnimation === null || tiltAnimation === void 0 ? void 0 : tiltAnimation.enable) {
            particle.tilt.decay = 1 - Object(esm["F" /* getRangeValue */])(tiltAnimation.decay);
            particle.tilt.velocity = (Object(esm["F" /* getRangeValue */])(tiltAnimation.speed) / 360) * this.container.retina.reduceFactor;
            if (!tiltAnimation.sync) {
                particle.tilt.velocity *= Object(esm["C" /* getRandom */])();
            }
        }
    }
    isEnabled(particle) {
        var _a;
        const tiltAnimation = (_a = particle.options.tilt) === null || _a === void 0 ? void 0 : _a.animation;
        return !particle.destroyed && !particle.spawning && !!(tiltAnimation === null || tiltAnimation === void 0 ? void 0 : tiltAnimation.enable);
    }
    loadOptions(options, ...sources) {
        if (!options.tilt) {
            options.tilt = new Tilt_Tilt();
        }
        for (const source of sources) {
            options.tilt.load(source === null || source === void 0 ? void 0 : source.tilt);
        }
    }
    update(particle, delta) {
        if (!this.isEnabled(particle)) {
            return;
        }
        updateTilt(particle, delta);
    }
}

// CONCATENATED MODULE: ./node_modules/tsparticles-updater-tilt/esm/index.js

async function loadTiltUpdater(engine) {
    await engine.addParticleUpdater("tilt", (container) => new TiltUpdater_TiltUpdater(container));
}

// CONCATENATED MODULE: ./node_modules/tsparticles-updater-twinkle/esm/Options/Classes/TwinkleValues.js

class TwinkleValues_TwinkleValues {
    constructor() {
        this.enable = false;
        this.frequency = 0.05;
        this.opacity = 1;
    }
    load(data) {
        if (!data) {
            return;
        }
        if (data.color !== undefined) {
            this.color = esm["d" /* OptionsColor */].create(this.color, data.color);
        }
        if (data.enable !== undefined) {
            this.enable = data.enable;
        }
        if (data.frequency !== undefined) {
            this.frequency = data.frequency;
        }
        if (data.opacity !== undefined) {
            this.opacity = Object(esm["Y" /* setRangeValue */])(data.opacity);
        }
    }
}

// CONCATENATED MODULE: ./node_modules/tsparticles-updater-twinkle/esm/Options/Classes/Twinkle.js

class Twinkle_Twinkle {
    constructor() {
        this.lines = new TwinkleValues_TwinkleValues();
        this.particles = new TwinkleValues_TwinkleValues();
    }
    load(data) {
        if (!data) {
            return;
        }
        this.lines.load(data.lines);
        this.particles.load(data.particles);
    }
}

// CONCATENATED MODULE: ./node_modules/tsparticles-updater-twinkle/esm/TwinkleUpdater.js


class TwinkleUpdater_TwinkleUpdater {
    getColorStyles(particle, context, radius, opacity) {
        const pOptions = particle.options, twinkleOptions = pOptions.twinkle;
        if (!twinkleOptions) {
            return {};
        }
        const twinkle = twinkleOptions.particles, twinkling = twinkle.enable && Object(esm["C" /* getRandom */])() < twinkle.frequency, zIndexOptions = particle.options.zIndex, zOpacityFactor = (1 - particle.zIndexFactor) ** zIndexOptions.opacityRate, twinklingOpacity = twinkling ? Object(esm["F" /* getRangeValue */])(twinkle.opacity) * zOpacityFactor : opacity, twinkleRgb = Object(esm["U" /* rangeColorToHsl */])(twinkle.color), twinkleStyle = twinkleRgb ? Object(esm["G" /* getStyleFromHsl */])(twinkleRgb, twinklingOpacity) : undefined, res = {}, needsTwinkle = twinkling && twinkleStyle;
        res.fill = needsTwinkle ? twinkleStyle : undefined;
        res.stroke = needsTwinkle ? twinkleStyle : undefined;
        return res;
    }
    init() {
    }
    isEnabled(particle) {
        const pOptions = particle.options, twinkleOptions = pOptions.twinkle;
        if (!twinkleOptions) {
            return false;
        }
        return twinkleOptions.particles.enable;
    }
    loadOptions(options, ...sources) {
        if (!options.twinkle) {
            options.twinkle = new Twinkle_Twinkle();
        }
        for (const source of sources) {
            options.twinkle.load(source === null || source === void 0 ? void 0 : source.twinkle);
        }
    }
    update() {
    }
}

// CONCATENATED MODULE: ./node_modules/tsparticles-updater-twinkle/esm/index.js

async function loadTwinkleUpdater(engine) {
    await engine.addParticleUpdater("twinkle", () => new TwinkleUpdater_TwinkleUpdater());
}

// CONCATENATED MODULE: ./node_modules/tsparticles-updater-wobble/esm/Options/Classes/WobbleSpeed.js

class WobbleSpeed_WobbleSpeed {
    constructor() {
        this.angle = 50;
        this.move = 10;
    }
    load(data) {
        if (!data) {
            return;
        }
        if (data.angle !== undefined) {
            this.angle = Object(esm["Y" /* setRangeValue */])(data.angle);
        }
        if (data.move !== undefined) {
            this.move = Object(esm["Y" /* setRangeValue */])(data.move);
        }
    }
}

// CONCATENATED MODULE: ./node_modules/tsparticles-updater-wobble/esm/Options/Classes/Wobble.js


class Wobble_Wobble {
    constructor() {
        this.distance = 5;
        this.enable = false;
        this.speed = new WobbleSpeed_WobbleSpeed();
    }
    load(data) {
        if (!data) {
            return;
        }
        if (data.distance !== undefined) {
            this.distance = Object(esm["Y" /* setRangeValue */])(data.distance);
        }
        if (data.enable !== undefined) {
            this.enable = data.enable;
        }
        if (data.speed !== undefined) {
            if (typeof data.speed === "number") {
                this.speed.load({ angle: data.speed });
            }
            else {
                const rangeSpeed = data.speed;
                if (rangeSpeed.min !== undefined) {
                    this.speed.load({ angle: rangeSpeed });
                }
                else {
                    this.speed.load(data.speed);
                }
            }
        }
    }
}

// CONCATENATED MODULE: ./node_modules/tsparticles-updater-wobble/esm/WobbleUpdater.js


function updateWobble(particle, delta) {
    var _a;
    const wobble = particle.options.wobble;
    if (!(wobble === null || wobble === void 0 ? void 0 : wobble.enable) || !particle.wobble) {
        return;
    }
    const angleSpeed = particle.wobble.angleSpeed * delta.factor, moveSpeed = particle.wobble.moveSpeed * delta.factor, distance = (moveSpeed * (((_a = particle.retina.wobbleDistance) !== null && _a !== void 0 ? _a : 0) * delta.factor)) / (1000 / 60), max = 2 * Math.PI;
    particle.wobble.angle += angleSpeed;
    if (particle.wobble.angle > max) {
        particle.wobble.angle -= max;
    }
    particle.position.x += distance * Math.cos(particle.wobble.angle);
    particle.position.y += distance * Math.abs(Math.sin(particle.wobble.angle));
}
class WobbleUpdater_WobbleUpdater {
    constructor(container) {
        this.container = container;
    }
    init(particle) {
        var _a;
        const wobbleOpt = particle.options.wobble;
        if (wobbleOpt === null || wobbleOpt === void 0 ? void 0 : wobbleOpt.enable) {
            particle.wobble = {
                angle: Object(esm["C" /* getRandom */])() * Math.PI * 2,
                angleSpeed: Object(esm["F" /* getRangeValue */])(wobbleOpt.speed.angle) / 360,
                moveSpeed: Object(esm["F" /* getRangeValue */])(wobbleOpt.speed.move) / 10,
            };
        }
        else {
            particle.wobble = {
                angle: 0,
                angleSpeed: 0,
                moveSpeed: 0,
            };
        }
        particle.retina.wobbleDistance = Object(esm["F" /* getRangeValue */])((_a = wobbleOpt === null || wobbleOpt === void 0 ? void 0 : wobbleOpt.distance) !== null && _a !== void 0 ? _a : 0) * this.container.retina.pixelRatio;
    }
    isEnabled(particle) {
        var _a;
        return !particle.destroyed && !particle.spawning && !!((_a = particle.options.wobble) === null || _a === void 0 ? void 0 : _a.enable);
    }
    loadOptions(options, ...sources) {
        if (!options.wobble) {
            options.wobble = new Wobble_Wobble();
        }
        for (const source of sources) {
            options.wobble.load(source === null || source === void 0 ? void 0 : source.wobble);
        }
    }
    update(particle, delta) {
        if (!this.isEnabled(particle)) {
            return;
        }
        updateWobble(particle, delta);
    }
}

// CONCATENATED MODULE: ./node_modules/tsparticles-updater-wobble/esm/index.js

async function loadWobbleUpdater(engine) {
    await engine.addParticleUpdater("wobble", (container) => new WobbleUpdater_WobbleUpdater(container));
}

// CONCATENATED MODULE: ./node_modules/tsparticles/esm/index.js









async function loadFull(engine) {
    await loadSlim(engine);
    await loadDestroyUpdater(engine);
    await loadRollUpdater(engine);
    await loadTiltUpdater(engine);
    await loadTwinkleUpdater(engine);
    await loadWobbleUpdater(engine);
    await loadExternalTrailInteraction(engine);
    await loadAbsorbersPlugin(engine);
    await loadEmittersPlugin(engine);
}

// CONCATENATED MODULE: ./src/configs/tsParticlesConfig.js
var tsParticlesConfig = {
  autoPlay: true,
  defaultThemes: {},
  delay: 0,
  fullScreen: {
    enable: true,
    zIndex: 1
  },
  detectRetina: true,
  duration: 0,
  fpsLimit: 120,
  interactivity: {
    detectsOn: "window",
    events: {
      onClick: {
        enable: false
      },
      onDiv: {
        enable: false
      },
      onHover: {
        enable: false
      },
      resize: {
        delay: 0.5,
        enable: true
      }
    },
    modes: {
      attract: {
        distance: 200,
        duration: 0.4,
        easing: "ease-out-quad",
        factor: 1,
        maxSpeed: 50,
        speed: 1
      },
      bounce: {
        distance: 200
      },
      bubble: {
        distance: 400,
        duration: 2,
        mix: false,
        opacity: 0.8,
        size: 40,
        divs: {
          distance: 200,
          duration: 0.4,
          mix: false,
          selectors: []
        }
      },
      connect: {
        distance: 80,
        links: {
          opacity: 0.5
        },
        radius: 60
      },
      grab: {
        distance: 400,
        links: {
          blink: false,
          consent: false,
          opacity: 1
        }
      },
      push: {
        default: true,
        groups: [],
        quantity: 4
      },
      remove: {
        quantity: 2
      },
      repulse: {
        distance: 200,
        duration: 0.4,
        factor: 100,
        speed: 1,
        maxSpeed: 50,
        easing: "ease-out-quad",
        divs: {
          distance: 200,
          duration: 0.4,
          factor: 100,
          speed: 1,
          maxSpeed: 50,
          easing: "ease-out-quad",
          selectors: []
        }
      },
      slow: {
        factor: 3,
        radius: 200
      },
      trail: {
        delay: 1,
        pauseOnStop: false,
        quantity: 1
      },
      light: {
        area: {
          gradient: {
            start: {
              value: "#ffffff"
            },
            stop: {
              value: "#000000"
            }
          },
          radius: 1000
        },
        shadow: {
          color: {
            value: "#000000"
          },
          length: 2000
        }
      }
    }
  },
  manualParticles: [],
  particles: {
    bounce: {
      horizontal: {
        random: {
          enable: false,
          minimumValue: 0.1
        },
        value: 1
      },
      vertical: {
        random: {
          enable: false,
          minimumValue: 0.1
        },
        value: 1
      }
    },
    collisions: {
      absorb: {
        speed: 2
      },
      bounce: {
        horizontal: {
          random: {
            enable: false,
            minimumValue: 0.1
          },
          value: 1
        },
        vertical: {
          random: {
            enable: false,
            minimumValue: 0.1
          },
          value: 1
        }
      },
      enable: true,
      mode: "bounce",
      overlap: {
        enable: true,
        retries: 0
      }
    },
    color: {
      value: "#ffffff",
      animation: {
        h: {
          count: 0,
          enable: false,
          offset: 0,
          speed: 1,
          decay: 0,
          sync: true
        },
        s: {
          count: 0,
          enable: false,
          offset: 0,
          speed: 1,
          decay: 0,
          sync: true
        },
        l: {
          count: 0,
          enable: false,
          offset: 0,
          speed: 1,
          decay: 0,
          sync: true
        }
      }
    },
    move: {
      angle: {
        offset: 0,
        value: 90
      },
      attract: {
        distance: 200,
        enable: false,
        rotate: {
          x: 600,
          y: 1200
        }
      },
      center: {
        x: 50,
        y: 50,
        mode: "percent",
        radius: 0
      },
      decay: 0,
      distance: {},
      direction: "none",
      drift: 0,
      enable: true,
      gravity: {
        acceleration: 9.81,
        enable: false,
        inverse: false,
        maxSpeed: 50
      },
      path: {
        clamp: true,
        delay: {
          random: {
            enable: false,
            minimumValue: 0
          },
          value: 0
        },
        enable: false,
        options: {}
      },
      outModes: {
        default: "out",
        bottom: "out",
        left: "out",
        right: "out",
        top: "out"
      },
      random: false,
      size: false,
      speed: 2,
      spin: {
        acceleration: 0,
        enable: false
      },
      straight: false,
      trail: {
        enable: false,
        length: 5,
        fill: {}
      },
      vibrate: false,
      warp: false
    },
    number: {
      density: {
        enable: false,
        width: 1920,
        height: 1080
      },
      limit: 0,
      value: 10
    },
    opacity: {
      random: {
        enable: false
      },
      animation: {
        enable: false
      }
    },
    reduceDuplicates: true,
    shadow: {
      blur: 0,
      color: {
        value: "#000"
      },
      enable: false,
      offset: {
        x: 0,
        y: 0
      }
    },
    shape: {
      options: {
        character: {
          fill: false,
          font: "Verdana",
          style: "",
          value: "*",
          weight: "400"
        },
        char: {
          fill: false,
          font: "Verdana",
          style: "",
          value: "*",
          weight: "400"
        },
        polygon: {
          sides: 5
        },
        star: {
          sides: 5
        },
        image: [{
          src: __webpack_require__("edd5"),
          width: 20,
          height: 40
        }, {
          src: __webpack_require__("1f58"),
          width: 32,
          height: 50
        }, {
          src: __webpack_require__("c035"),
          width: 40,
          height: 40
        }]
      },
      type: "image"
    },
    size: {
      random: {
        enable: false,
        minimumValue: 1
      },
      value: 16,
      animation: {
        count: 0,
        enable: false,
        speed: 40,
        decay: 0,
        sync: false,
        destroy: "none",
        startValue: "random",
        minimumValue: 0.1
      }
    },
    stroke: {
      width: 0,
      color: {
        value: "#000000",
        animation: {
          h: {
            count: 0,
            enable: false,
            offset: 0,
            speed: 1,
            decay: 0,
            sync: true
          },
          s: {
            count: 0,
            enable: false,
            offset: 0,
            speed: 1,
            decay: 0,
            sync: true
          },
          l: {
            count: 0,
            enable: false,
            offset: 0,
            speed: 1,
            decay: 0,
            sync: true
          }
        }
      }
    },
    zIndex: {
      random: {
        enable: false,
        minimumValue: 0
      },
      value: 0,
      opacityRate: 1,
      sizeRate: 1,
      velocityRate: 1
    },
    life: {
      count: 0,
      delay: {
        random: {
          enable: false,
          minimumValue: 0
        },
        value: 0,
        sync: false
      },
      duration: {
        random: {
          enable: false,
          minimumValue: 0.0001
        },
        value: 0,
        sync: false
      }
    },
    rotate: {
      random: {
        enable: true,
        minimumValue: 0
      },
      value: 0,
      animation: {
        enable: true,
        speed: 5,
        decay: 0,
        sync: false
      },
      direction: "random",
      path: false
    },
    destroy: {
      bounds: {},
      mode: "none",
      split: {
        count: 1,
        factor: {
          random: {
            enable: false,
            minimumValue: 0
          },
          value: 3
        },
        rate: {
          random: {
            enable: false,
            minimumValue: 0
          },
          value: {
            min: 4,
            max: 9
          }
        },
        sizeOffset: true
      }
    },
    roll: {
      darken: {
        enable: false,
        value: 0
      },
      enable: false,
      enlighten: {
        enable: false,
        value: 0
      },
      mode: "vertical",
      speed: 25
    },
    tilt: {
      random: {
        enable: false,
        minimumValue: 0
      },
      value: 0,
      animation: {
        enable: false,
        speed: 0,
        decay: 0,
        sync: false
      },
      direction: "clockwise",
      enable: false
    },
    twinkle: {
      lines: {
        enable: false,
        frequency: 0.05,
        opacity: 1
      },
      particles: {
        enable: false,
        frequency: 0.05,
        opacity: 1
      }
    },
    wobble: {
      distance: 5,
      enable: false,
      speed: {
        angle: 50,
        move: 10
      }
    },
    orbit: {
      animation: {
        count: 0,
        enable: false,
        speed: 1,
        decay: 0,
        sync: false
      },
      enable: false,
      opacity: 1,
      rotation: {
        random: {
          enable: false,
          minimumValue: 0
        },
        value: 45
      },
      width: 1
    },
    links: {
      blink: false,
      color: {
        value: "#000"
      },
      consent: false,
      distance: 150,
      enable: false,
      frequency: 1,
      opacity: 0.4,
      shadow: {
        blur: 5,
        color: {
          value: "#000"
        },
        enable: false
      },
      triangles: {
        enable: false,
        frequency: 1
      },
      width: 1,
      warp: false
    },
    repulse: {
      random: {
        enable: false,
        minimumValue: 0
      },
      value: 0,
      enabled: false,
      distance: 1,
      duration: 1,
      factor: 1,
      speed: 1
    }
  },
  pauseOnBlur: true,
  pauseOnOutsideViewport: true,
  responsive: [],
  smooth: false,
  style: {},
  themes: [],
  zLayers: 100
};

// CONCATENATED MODULE: ./node_modules/cache-loader/dist/cjs.js??ref--13-0!./node_modules/thread-loader/dist/cjs.js!./node_modules/babel-loader/lib!./node_modules/eslint-loader??ref--14-0!./src/scripts/Presentation.js?vue&type=script&lang=js&




/* harmony default export */ var Presentationvue_type_script_lang_js_ = ({
  props: ["isPresentationsInFullScreen", "curSlideOverride"],
  mounted: function mounted() {
    var slides = document.querySelectorAll(".slide");
    this.totalSlides = slides.length;
    this.addKeyboardEventsToToggleSlides();
  },
  unmounted: function unmounted() {
    window.removeEventListener("keyup");
  },
  data: function data() {
    return {
      curSlide: 0,
      totalSlides: undefined,
      tsParticlesConfig: tsParticlesConfig
    };
  },
  methods: {
    particlesInit: function () {
      var _particlesInit = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(engine) {
        return _regeneratorRuntime().wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                _context.next = 2;
                return loadFull(engine);

              case 2:
              case "end":
                return _context.stop();
            }
          }
        }, _callee);
      }));

      function particlesInit(_x) {
        return _particlesInit.apply(this, arguments);
      }

      return particlesInit;
    }(),
    nextSlide: function nextSlide() {
      this.$parent.updateCurSlideOverride(null);

      if (this.curSlide === this.totalSlides - 1) {
        this.curSlide = 0;
      } else {
        this.curSlide++;
      }
    },
    prevSlide: function prevSlide() {
      this.$parent.updateCurSlideOverride(null);

      if (this.curSlide === 0) {
        this.curSlide = this.totalSlides - 1;
      } else {
        this.curSlide--;
      }
    },
    addKeyboardEventsToToggleSlides: function addKeyboardEventsToToggleSlides() {
      var _this = this;

      window.addEventListener("keyup", function (e) {
        if (e.key === "ArrowRight") {
          _this.nextSlide();
        } else if (e.key === "ArrowLeft") {
          _this.prevSlide();
        }
      });
    },
    updateCurSlide: function updateCurSlide(slideNumber) {
      this.$parent.updateCurSlideOverride(null);
      this.curSlide = slideNumber;
    }
  }
});
// CONCATENATED MODULE: ./src/scripts/Presentation.js?vue&type=script&lang=js&
 /* harmony default export */ var scripts_Presentationvue_type_script_lang_js_ = (Presentationvue_type_script_lang_js_); 
// EXTERNAL MODULE: ./src/styles/Modal.scss?vue&type=style&index=0&id=4c57d58f&scoped=true&lang=scss&
var Modalvue_type_style_index_0_id_4c57d58f_scoped_true_lang_scss_ = __webpack_require__("d495");

// EXTERNAL MODULE: ./src/styles/Presentation.scss?vue&type=style&index=1&id=4c57d58f&scoped=true&lang=scss&
var Presentationvue_type_style_index_1_id_4c57d58f_scoped_true_lang_scss_ = __webpack_require__("1aca");

// EXTERNAL MODULE: ./src/styles/customStyle.scss?vue&type=style&index=2&id=4c57d58f&scoped=true&lang=scss&
var customStylevue_type_style_index_2_id_4c57d58f_scoped_true_lang_scss_ = __webpack_require__("6c37");

// EXTERNAL MODULE: ./node_modules/vue-loader/lib/runtime/componentNormalizer.js
var componentNormalizer = __webpack_require__("2877");

// EXTERNAL MODULE: ./node_modules/vuetify-loader/lib/runtime/installComponents.js
var installComponents = __webpack_require__("6544");
var installComponents_default = /*#__PURE__*/__webpack_require__.n(installComponents);

// EXTERNAL MODULE: ./node_modules/vuetify/lib/components/VIcon/VIcon.js + 3 modules
var VIcon = __webpack_require__("132d");

// CONCATENATED MODULE: ./src/components/Presentation.vue








/* normalize component */

var component = Object(componentNormalizer["a" /* default */])(
  scripts_Presentationvue_type_script_lang_js_,
  render,
  staticRenderFns,
  false,
  null,
  "4c57d58f",
  null
  
)

/* harmony default export */ var Presentation = __webpack_exports__["default"] = (component.exports);

/* vuetify-loader */


installComponents_default()(component, {VIcon: VIcon["a" /* default */]})


/***/ }),

/***/ "3a19":
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__.p + "img/profile.e62d3410.jpg";

/***/ }),

/***/ "54bd":
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),

/***/ "6c37":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var _node_modules_mini_css_extract_plugin_dist_loader_js_ref_9_oneOf_1_0_node_modules_css_loader_dist_cjs_js_ref_9_oneOf_1_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_src_index_js_ref_9_oneOf_1_2_node_modules_sass_loader_dist_cjs_js_ref_9_oneOf_1_3_customStyle_scss_vue_type_style_index_2_id_4c57d58f_scoped_true_lang_scss___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("d5a6");
/* harmony import */ var _node_modules_mini_css_extract_plugin_dist_loader_js_ref_9_oneOf_1_0_node_modules_css_loader_dist_cjs_js_ref_9_oneOf_1_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_src_index_js_ref_9_oneOf_1_2_node_modules_sass_loader_dist_cjs_js_ref_9_oneOf_1_3_customStyle_scss_vue_type_style_index_2_id_4c57d58f_scoped_true_lang_scss___WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_mini_css_extract_plugin_dist_loader_js_ref_9_oneOf_1_0_node_modules_css_loader_dist_cjs_js_ref_9_oneOf_1_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_src_index_js_ref_9_oneOf_1_2_node_modules_sass_loader_dist_cjs_js_ref_9_oneOf_1_3_customStyle_scss_vue_type_style_index_2_id_4c57d58f_scoped_true_lang_scss___WEBPACK_IMPORTED_MODULE_0__);
/* unused harmony reexport * */


/***/ }),

/***/ "944a":
/***/ (function(module, exports, __webpack_require__) {

var getBuiltIn = __webpack_require__("d066");
var defineWellKnownSymbol = __webpack_require__("746f");
var setToStringTag = __webpack_require__("d44e");

// `Symbol.toStringTag` well-known symbol
// https://tc39.es/ecma262/#sec-symbol.tostringtag
defineWellKnownSymbol('toStringTag');

// `Symbol.prototype[@@toStringTag]` property
// https://tc39.es/ecma262/#sec-symbol.prototype-@@tostringtag
setToStringTag(getBuiltIn('Symbol'), 'Symbol');


/***/ }),

/***/ "b636":
/***/ (function(module, exports, __webpack_require__) {

var defineWellKnownSymbol = __webpack_require__("746f");

// `Symbol.asyncIterator` well-known symbol
// https://tc39.es/ecma262/#sec-symbol.asynciterator
defineWellKnownSymbol('asyncIterator');


/***/ }),

/***/ "c035":
/***/ (function(module, exports) {

module.exports = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACgAAAAoCAYAAACM/rhtAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAbxSURBVHgBtVh9bJXVGX+ec963pZd+3DGsHZ18tqtkBlAmVFc3dHMm05gsi2zZhnDBjLhkpBaMc5tS/GM08tHGbMsyB7QytgQyYtTpglmkUWxFEcT4wXerGGlArfe29Pa+73sef6ftrbXcKve+7S9p3vOe+5xzfu/zPOd3nlOiCcTxG4ruP3lj4S0UAoomEBJInxh+iEJgQgmSUrOJuObMkmiUcsSEElQk1+Lh+Im+r1OOmDCCZ6qjM+G9JbZtmIRyxIQQPIyQBhL8z7ZF6EzVa/2nKUeMO8G3FxdXFiaDg8JcNdDBpolCgGkccfKGktVkpEGYhjYFv1HZ/ukCCgGHxgE2pJGkaRKR5elPRtJ1cH9wq22/tvAbkRK39ycIV+mc9nhjNnOHJnj6xuiMIBk8B2/NTfeB3MHepLptwZH4pyeqC+9l6X0E5I/GC/RPKUuECvGJmwqvIE+9guasERP+7fiF0tqKr51bzI76K9h+m1gaKtoSv2fKfjeH2yQptX4kOaCuoj1+77emnF/DWrVacsjHhyvbEg/mQs4iZw8eWzR5vlL6yOcTya8r2hOPH19c/BAzPTLUvaGyPV5PIZCzB7VSvxh+Edluyb0DcU6Tg/4dC0suFEEhnjbcZnrRPh0OfjA8MUsbjQNCEKTO4bbwrMEnBek+Q3zn4RBFQho5E2Q2zw9PomRAYpiCo8O/E02Z3GfWU0iEk5nqohcGCgKm7rP58Stu3k8+Nkkb8rA6beMbmTr3YOIjyhGhZKaHdIyFuhHv6LRkyRLbx8b8bqSNo3kZhUAogte2d3cYFfzGtlmk1j4rX+1pFZIH0jZGqIRCYFyKhWPVRXWKeKPxpLzqUOKC7TtRXTwozF5/ReWh/lOUI7I6i2u39c0mx5kNMmUIbSRf66f/tIw/rGpPbD21aPKHnKdqYPakLbkGBohsHE2udodEHeXXGqIfIldnYJ4LgTGbGmP5/8qJ4JoWme6S9yicfRterWx0C5lnsMD+TxI9ybTdnIO9/06380jdaShoqWxP/OHSGCWjYpwUyJ3Hy/Vw8zeVUrvub/Y6N61wD4y2/soQr23xH4cr7hky70VWPWgMH2EVdBkjqUxjqk7srXq36meuNmaq0roY4+dBIyHsUq59p+bRVZywdrU7+mZq5Ry2Hw4tbd66wollT3CHv0yUtHCYfGV6VUT95/0CtXnPUg6+MH+LZ08cK0tvbFnuXlLcfmWIt8ScnfjSF1npH0NO7kL+lWLB6fip8BJjIQ8K/gG8HIdAwDPmMAXy/JaV+W9nmvu+nckKHDlDmilHKeO3ZQGb4EqZ1YpNmfKch/1IX9QkWRslxnULLhYdp4/r69mMHHPXbtGjvTY4lw2vC6GXmXiNB8af3xQr6AhFsK45dYiZr8Ow/5KYpxS5HZ74qRGTTVKKr4QXp0ILr4E2Xo9ue3nvCox3c5rAml3JStd39llymO+U73k/alpVkPHml5XMKOansOtAUG4HidsN+aQv+UQZqBq+2C0lmp0/o3FH3fbUava5AeTfwzHxx86n9zbs2bM0GGvNrBPfhoZF3wGZqIG35oDKVBwjDmouf8jkJPidRV+HEn4niOgDjUttXg5ibUvwW9cJXm74Zd6hy1kvB4LIQ/buRqIlm1bk/Z0mGFkTrHvC/wfCswpe6mLF+yQIkDv8nmHVpZVG8eKVYadfjYt7GfL0+/B0azIV1P/lnoJOygFZE1zX4q1HltVnMwb5esEEyVsaY4VvUpYYc5MMhJJSt7J25mJHzmIxERxJuzctczbU7kidRv79nIW/i1wbq1qxx+AxYfOsCtS+TORsPruip2xamff6WDwyerCu2VunFG1EGJH89Byk4J++0c82xbh7tO1jj0n+qSJvnks82b6L8nwJqHPrysj79CW4b1vqO7jE/AoqcN3mu93vZUUQ528rlhoYhF3aoZj+bwLzEu4ZHYacD3oMnds+dJ5+GdY9IaV+kIwQO+Ws5GrNukqMmYdl52PmMph0K81rPU/vtUXEZQt13c7UfDLqSR5U+cywlTSnPWogMVZmZFK6BsZGKsVtL5JhZBKR2a9JnvHE3aUptYSUbkTZ9cDmFc7uyyKYxtrm1EJY1CBuC7DidJTHk7B+OYZdiZ8njUEcjqYuPLuwmT5ilrNMfB6Vz1s+mQM9Jv9cVPuLEJWbME8M+T0ddhu2LnfrM0132bvYbhqtg8bh/18YEzCri5CaJMIW2CsnK5QGuNODnANieWKoGFc+DZ8qELEfdRV+s8Wsa88beK0Vfxs2x9z9Y62blcys3Ha+aIqKLsRy12DoDENyFbxTLkamQe9caF8JFiyAqQaBJPp6YHcRXPrx363XsVocG+40/v3/ZmDy2zJtutH4DFGa0pOgDX1YAAAAAElFTkSuQmCC"

/***/ }),

/***/ "d495":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var _node_modules_mini_css_extract_plugin_dist_loader_js_ref_9_oneOf_1_0_node_modules_css_loader_dist_cjs_js_ref_9_oneOf_1_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_src_index_js_ref_9_oneOf_1_2_node_modules_sass_loader_dist_cjs_js_ref_9_oneOf_1_3_Modal_scss_vue_type_style_index_0_id_4c57d58f_scoped_true_lang_scss___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("1f49");
/* harmony import */ var _node_modules_mini_css_extract_plugin_dist_loader_js_ref_9_oneOf_1_0_node_modules_css_loader_dist_cjs_js_ref_9_oneOf_1_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_src_index_js_ref_9_oneOf_1_2_node_modules_sass_loader_dist_cjs_js_ref_9_oneOf_1_3_Modal_scss_vue_type_style_index_0_id_4c57d58f_scoped_true_lang_scss___WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_mini_css_extract_plugin_dist_loader_js_ref_9_oneOf_1_0_node_modules_css_loader_dist_cjs_js_ref_9_oneOf_1_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_src_index_js_ref_9_oneOf_1_2_node_modules_sass_loader_dist_cjs_js_ref_9_oneOf_1_3_Modal_scss_vue_type_style_index_0_id_4c57d58f_scoped_true_lang_scss___WEBPACK_IMPORTED_MODULE_0__);
/* unused harmony reexport * */


/***/ }),

/***/ "d5a6":
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),

/***/ "edd5":
/***/ (function(module, exports) {

module.exports = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACgAAABUCAYAAADwHnXXAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAANZSURBVHgB7ZvPSxtBFMdnJhv8UcVALyIsQTDFlhK8iCcvtfEiUv8AKb33ovRWPHos6aX/gCcvHnoo2HoTeimUHoTQa2tqCXiQUBvdZLPb94YdutnsJpsO1ReYDzxnM5vZ/e5782bXnQlnAfv7+88ODw+fOo5z3/O8nO/7owCDMtEUcXXhfeEy2PbD+6+urrxsNttotVq1hYWFyurq6stSqfQV93P8s729/e7o6GgNvtBTUD+LExUVmCC4Y9u2bX93d/fFxsbGa35wcPB8Z2fnDXiNhDjF/Py8u7e3dy8Dla9qtVo+7qScCca5YO22KxvhRbTbbaiTjpdl1IQQXZbJZOTxsH2cmLjP5+fnYnZ29pcFfa4YJw4PJvCkgnd5Cdp0HBiFJXki+r004tTFVyqVggVXN6UEqS+qbdeDPul2hgobQof+62XOU4czrThVf3FxcccKJ0ZYXFwf6+oCKcWlFRuth+zmFnqjX4KkFZeULFExScKi+8bGxpiFFaenp5cg8jf7j/QSFQc44C6WVuC9a7A6o8WUTFTYGOzSbhgxqOtvEtQmwoMnNaTAaPZRQvbBofAgZUgLVMMMaYxAXYR6RqOIfOAlnsU+6RBLDzLCyP9xGHFIJwlCPcScdBbDG4Y1+iGm7EGTxbpAdD3SHjw7O3tPPUloe1COg4wwMzMzj0kLhFeDI+aRXxfzNKPDcNzqGHFI90ETYl3q9fpnFEg2xo1Go2ZCrIu5k+hC/1ZnQqwJ/akw8vMkjDj0Q8wII2eazFydBuSzeDgmE00Wa2CyWBfyIUZMiHUwA7UuQzEOWkGIR8AmGSHUDAQK5JMAIyYQAQ/K+WKyq8tgGsJDgdeMKOPj444F5TewB4M0xNXog6JWqacFc2N6evq7VSgUPpycnKQWiJmFv5IY9I0ErtfGtmnbTUxMsHw+/1asrKyU5+bmUq8ARi/gyZrN5kAWXiqfhsXFxU9bW1sfxebm5o/l5eUSVPxUS+BvA3VeHFCWlpaO19fXn+BnHli2WCzmQOSjarX6ELLHdhxn1LIsTCL5mhiHo+BY0ZKF9nUAHgtfrR8ucR8YjiCe67ptOOdlLper2rb9pVwuH0M9Jm9LHVgExntYrDjW/x13osigTDIpXvfdW9r2/9xv/gA8KUAxkdkkmAAAAABJRU5ErkJggg=="

/***/ })

}]);
//# sourceMappingURL=chunk-1335b12d.c98b9d2a.js.map